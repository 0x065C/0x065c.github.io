# Index 
- [[3. Common Malware Techniques]]
	- [[3.1 Process Injection Techniques]]
	- [[3.2 Persistence Mechanisms]]
	- [[3.3 Hooking Windows APIs]]
	- [[3.4 Packing & Encryption]]

# Overview of Windows API Hooking

There are various methods to hook APIs in Windows:
1. Import Address Table (IAT) Hooking
2. Inline Hooking (also known as function detouring)
3. User-mode Hooking using libraries like Microsoft Detours or MinHook
4. Kernel-mode Hooking (requires writing drivers, and this approach is more complex and dangerous)

We'll focus on user-mode hooking techniques that are commonly used in malware.

# IAT Hooking
The Import Address Table (IAT) is a structure used by Windows PE (Portable Executable) files that contains pointers to functions imported from DLLs. IAT hooking involves modifying the function pointers in the IAT to redirect them to your own code, allowing you to intercept API calls.

#### IAT Hooking Example

Let’s hook the `MessageBoxW` function, a common API used to display message boxes, by modifying its entry in the IAT.

##### Step-by-Step Explanation

1. Locate the IAT: Each PE file has an IAT that lists all the functions it imports from external DLLs.
2. Modify the Function Pointer: Replace the function pointer in the IAT with the address of your custom function (hook).
3. Call the Original Function: If needed, your hook can still call the original function after doing its work.

##### Example Code: IAT Hooking in C++
This example demonstrates how to hook the `MessageBoxW` function using IAT hooking. It will intercept calls to `MessageBoxW` and replace the displayed text with "Hooked!"

```cpp
#include <windows.h>
#include <iostream>

// Define a function pointer type for MessageBoxW
typedef int (WINAPI *pMessageBoxW)(HWND, LPCWSTR, LPCWSTR, UINT);

// Pointer to store the original MessageBoxW
pMessageBoxW originalMessageBoxW = NULL;

// Hooked function that replaces MessageBoxW
int WINAPI HookedMessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType) {
    // Modify the text displayed in the message box
    return originalMessageBoxW(hWnd, L"Hooked Message!", L"Hooked Title!", uType);
}

// Function to hook IAT
void HookIAT() {
    // Get handle to the current module (the executable or DLL)
    HMODULE hModule = GetModuleHandle(NULL);
    
    if (hModule) {
        // Get the DOS header to locate the PE header
        PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)hModule;
        PIMAGE_NT_HEADERS ntHeaders = (PIMAGE_NT_HEADERS)((BYTE*)hModule + dosHeader->e_lfanew);

        // Get the import descriptor to locate the IAT
        PIMAGE_IMPORT_DESCRIPTOR importDesc = (PIMAGE_IMPORT_DESCRIPTOR)((BYTE*)hModule +
                                            ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);

        // Iterate over import descriptors to find "user32.dll"
        while (importDesc->Name) {
            const char* moduleName = (const char*)((BYTE*)hModule + importDesc->Name);
            if (_stricmp(moduleName, "user32.dll") == 0) {
                break;
            }
            importDesc++;
        }

        // Get the IAT (first thunk)
        PIMAGE_THUNK_DATA thunk = (PIMAGE_THUNK_DATA)((BYTE*)hModule + importDesc->FirstThunk);

        // Loop through IAT entries
        while (thunk->u1.Function) {
            PROC* pFunc = (PROC*)&thunk->u1.Function;
            if (*pFunc == (PROC)MessageBoxW) {
                // Unprotect the memory to modify the IAT
                DWORD oldProtect;
                VirtualProtect(pFunc, sizeof(PROC), PAGE_EXECUTE_READWRITE, &oldProtect);

                // Save the original MessageBoxW and replace it with our hooked function
                originalMessageBoxW = (pMessageBoxW)*pFunc;
                *pFunc = (PROC)HookedMessageBoxW;

                // Restore protection
                VirtualProtect(pFunc, sizeof(PROC), oldProtect, &oldProtect);

                std::cout << "IAT Hooking Complete: MessageBoxW hooked!" << std::endl;
                break;
            }
            thunk++;
        }
    }
}

int main() {
    // Hook MessageBoxW via IAT
    HookIAT();

    // Test the hook
    MessageBoxW(NULL, L"Original Message", L"Original Title", MB_OK);

    return 0;
}
```

#### How it Works
1. Locating the IAT: We parse the PE headers to find the IAT of the running module.
2. Finding the Target API: We look for `MessageBoxW` in the IAT.
3. Modifying the Function Pointer: The entry for `MessageBoxW` in the IAT is replaced with our own custom function (`HookedMessageBoxW`).
4. Original Function Call: Inside the hook, we can still call the original `MessageBoxW` function using the saved pointer.

##### AV Evasion Techniques
- Avoid common APIs: Hooking APIs like `MessageBoxW` might be flagged by AV because it is a common demo target. Hook less obvious or frequently used APIs.
- Dynamic API Resolution: Avoid using static API names or addresses. Resolve function addresses dynamically at runtime to make static analysis harder.

# Inline Hooking (Function Detouring)
Inline hooking involves modifying the first few instructions of the target function to redirect execution to your own code (detour). This method is more flexible and can hook functions that may not be imported via the IAT.

#### Inline Hooking Example

Let’s hook the `MessageBoxW` function again, but this time using inline hooking by modifying the function’s prologue.

##### Step-by-Step Explanation
1. Backup Original Instructions: Save the original bytes of the target function.
2. Overwrite the Function Prologue: Replace the first few instructions with a jump (JMP) to your hook function.
3. Execute the Original Function: In your hook function, execute the original instructions and then return to the original function.

##### Example Code: Inline Hooking in C++
```cpp
#include <windows.h>
#include <iostream>

typedef int (WINAPI *pMessageBoxW)(HWND, LPCWSTR, LPCWSTR, UINT);
pMessageBoxW originalMessageBoxW = NULL;

// Number of bytes to overwrite in the target function's prologue
const int HOOK_SIZE = 5;

// Function that will replace the original MessageBoxW
int WINAPI HookedMessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType) {
    // Print a message before calling the original function
    std::cout << "MessageBoxW Hooked!" << std::endl;

    // Call the original MessageBoxW
    return originalMessageBoxW(hWnd, L"Hooked Inline!", lpCaption, uType);
}

// Detour the MessageBoxW function
void DetourFunction(BYTE* src, BYTE* dst, const int len) {
    DWORD oldProtect;
    VirtualProtect(src, len, PAGE_EXECUTE_READWRITE, &oldProtect);

    // Write the jump instruction (0xE9 for near jump)
    DWORD relativeAddress = (DWORD)(dst - src) - 5;  // Calculate relative address for the jump
    *src = 0xE9;  // Opcode for JMP instruction
    *((DWORD*)(src + 1)) = relativeAddress;  // Write the relative address

    VirtualProtect(src, len, oldProtect, &oldProtect);
}

void HookInline() {
    // Get the address of the original MessageBoxW
    HMODULE hUser32 = GetModuleHandle(L"user32.dll");
    originalMessageBoxW = (pMessageBoxW)GetProcAddress(hUser32, "MessageBoxW");

    // Detour the MessageBoxW function to our hook
    DetourFunction((BYTE*)originalMessageBoxW, (BYTE*)HookedMessageBoxW, HOOK_SIZE);
}

int main() {
    // Hook MessageBoxW using inline hooking
    HookInline();

    // Test the hook
    MessageBoxW(NULL, L"Original Message", L"Original Title", MB_OK);

    return 0;
}
```

#### How it Works
1. Detour Setup: We overwrite the first few bytes of the target function (`MessageBoxW`) with a jump to our custom hook (`HookedMessageBoxW`).
2. JMP Instruction: The detour is set up using a JMP instruction, which redirects the flow of execution to our hook.
3. Restoring the Original: After processing the custom logic, we can call the original function.

##### AV Evasion Techniques
- Dynamic Hooks: Implement hooks dynamically at runtime rather than during the initial execution to make it harder for AV to detect.
- Polymorphism: Change the hook’s structure and how you place the hook in each execution to avoid detection by behavior-based analysis tools.

# Using Libraries for Hooking
While writing custom hooking code is possible, it's often easier to use well-established libraries like Microsoft Detours or MinHook. These libraries handle much of the low-level complexity of hooking and provide a robust framework for redirecting function calls.

#### Example: Hooking with MinHook

MinHook is a lightweight and fast API hooking library for Windows. Here’s how you can use MinHook to hook `MessageBoxW`:

```cpp
#include <windows.h>
#include <MinHook.h>
#include <iostream>

typedef int (WINAPI *pMessageBoxW)(HWND, LPCWSTR, LPCWSTR, UINT);
pMessageBoxW originalMessageBoxW = NULL;

int WINAPI HookedMessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType) {
    // Modify the message box text
    return originalMessageBoxW(hWnd, L"Hooked with MinHook!", lpCaption, uType);
}

int main() {
    // Initialize MinHook
    if (MH_Initialize() != MH_OK) {
        std::cerr << "Failed to initialize MinHook" << std::endl;
        return -1;
    }

    // Create a hook for MessageBoxW
    if (MH_CreateHookApi(L"user32", "MessageBoxW", &HookedMessageBoxW, reinterpret_cast<LPVOID*>(&originalMessageBoxW)) != MH_OK) {
        std::cerr << "Failed to create hook" << std::endl;
        return -1;
    }

    // Enable the hook
    if (MH_EnableHook(MH_ALL_HOOKS) != MH_OK) {
        std::cerr << "Failed to enable hook" << std::endl;
        return -1;
    }

    // Test the hook
    MessageBoxW(NULL, L"Original Message", L"Original Title", MB_OK);

    // Disable the hook
    MH_DisableHook(MH_ALL_HOOKS);

    // Cleanup
    MH_Uninitialize();
    
    return 0;
}
```
