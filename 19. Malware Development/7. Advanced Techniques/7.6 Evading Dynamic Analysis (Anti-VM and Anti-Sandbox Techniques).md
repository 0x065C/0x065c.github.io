# Index 
- [[7. Advanced Techniques]]
	- [[7.1 Code Reuse (API Unhooking and Windows Code Reuse)]]
	- [[7.2 Syscall Usage (Direct System Calls)]]
	- [[7.3 In-memory Execution (Reflective DLL Injection)]]
	- [[7.4 In-memory Execution of Shellcode (Payload Execution)]]
	- [[7.5 Reflective DLL Injection]]
	- [[7.6 Evading Dynamic Analysis (Anti-VM and Anti-Sandbox Techniques)]]

# Checking for Virtualization Artifacts
   Virtualization software, such as VMware, VirtualBox, and Hyper-V, often leaves artifacts in the system that can be detected.

#### Registry Key Checks
   Virtual environments tend to leave traces in the Windows registry. Malware can query specific registry keys to determine if it’s running inside a virtualized environment.

   Example: Checking for VMware or VirtualBox registry keys
   ```cpp
   #include <windows.h>
   #include <iostream>

   bool IsVirtualMachine() {
       HKEY hKey;
       const wchar_t* regPath = L"HARDWARE\\Description\\System\\BIOS";
       const wchar_t* value = L"SystemManufacturer";

       // Open the registry key
       if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, regPath, 0, KEY_READ, &hKey) == ERROR_SUCCESS) {
           wchar_t buffer[256];
           DWORD bufferSize = sizeof(buffer);
           // Query the value of SystemManufacturer
           if (RegQueryValueEx(hKey, value, NULL, NULL, (LPBYTE)buffer, &bufferSize) == ERROR_SUCCESS) {
               // Check if it contains known virtual machine identifiers
               if (wcsstr(buffer, L"VMware") || wcsstr(buffer, L"VirtualBox") || wcsstr(buffer, L"Xen")) {
                   RegCloseKey(hKey);
                   return true;
               }
           }
           RegCloseKey(hKey);
       }
       return false;
   }

   int main() {
       if (IsVirtualMachine()) {
           std::cout << "Running in a virtual machine!" << std::endl;
       } else {
           std::cout << "Not running in a virtual machine." << std::endl;
       }
   }
   ```

   Explanation: 
   This code checks the `SystemManufacturer` field in the Windows registry to identify if the system is running inside a virtualized environment by searching for known VM vendors.

#### Detecting Virtual Machine-Specific Drivers
   Virtual machines use specific drivers (e.g., for virtual NICs or mouse devices) that are absent in physical environments. Malware can enumerate installed drivers to check for the presence of these specific drivers.

   Example: Detecting VMware and VirtualBox drivers
   ```cpp
   #include <windows.h>
   #include <iostream>

   bool CheckVMDrivers() {
       const wchar_t* vmDrivers[] = {L"VBoxMouse.sys", L"VBoxGuest.sys", L"vmci.sys", L"vmhgfs.sys", L"vmx_svga.sys"};
       bool isVirtualized = false;

       // Loop through known virtual machine drivers
       for (auto& driver : vmDrivers) {
           if (GetModuleHandle(driver) != NULL) {
               std::wcout << L"Found VM driver: " << driver << std::endl;
               isVirtualized = true;
           }
       }
       return isVirtualized;
   }

   int main() {
       if (CheckVMDrivers()) {
           std::cout << "VM drivers detected!" << std::endl;
       } else {
           std::cout << "No VM drivers detected." << std::endl;
       }
   }
   ```

   Explanation:
   This code looks for specific VM drivers loaded into the system (like `VBoxMouse.sys` or `vmci.sys`), which are characteristic of virtualized environments.

# Checking for CPU Artifacts (CPUID Instruction)
   Virtual environments often expose specific CPU features that can be detected using the `CPUID` instruction. Malware can execute this instruction and check the returned data to detect virtualized environments.

#### CPUID Instruction to Detect Hypervisors
   The `CPUID` instruction can reveal the presence of a hypervisor if executed with the right parameters. If the hypervisor bit is set, it indicates the presence of virtualization.

   Example: Using CPUID to detect hypervisors
   ```cpp
   #include <iostream>
   #include <intrin.h>  // for __cpuid intrinsic

   bool IsHypervisorPresent() {
       int cpuInfo[4];
       __cpuid(cpuInfo, 1);  // Get processor info and features

       // Check the 31st bit in ECX (Hypervisor present bit)
       return (cpuInfo[2] & (1 << 31)) != 0;
   }

   int main() {
       if (IsHypervisorPresent()) {
           std::cout << "Hypervisor detected!" << std::endl;
       } else {
           std::cout << "No hypervisor detected." << std::endl;
       }
   }
   ```

   Explanation:
   This code calls the `__cpuid` intrinsic and checks the result for the hypervisor bit (bit 31 of the `ECX` register). If this bit is set, it indicates that the code is running inside a virtualized environment.

# Timing and Delayed Execution
   Sandboxes often execute malware in a constrained time window. By delaying execution for long periods or checking for anomalies in system timing, malware can evade sandbox detection.

#### Sleep Timing to Evade Sandboxes
   Some sandboxes artificially accelerate time to expedite analysis. Malware can compare time intervals or use high-precision timers to detect this acceleration and modify its behavior accordingly.

   Example: Using timing discrepancies to detect sandboxes
   ```cpp
   #include <windows.h>
   #include <iostream>

   bool CheckTimingDiscrepancy() {
       DWORD startTime = GetTickCount();
       Sleep(10000);  // Sleep for 10 seconds
       DWORD endTime = GetTickCount();

       DWORD elapsedTime = endTime - startTime;

       // If the sleep was shorter than expected, we may be in a sandbox
       if (elapsedTime < 10000) {
           std::cout << "Timing discrepancy detected!" << std::endl;
           return true;
       }
       return false;
   }

   int main() {
       if (CheckTimingDiscrepancy()) {
           std::cout << "Likely running in a sandbox!" << std::endl;
       } else {
           std::cout << "No timing issues detected." << std::endl;
       }
   }
   ```

   Explanation:
   This technique uses `Sleep` to pause for a known duration and then measures the actual elapsed time. If the elapsed time is significantly shorter than expected, the malware may be running inside a sandbox with time acceleration.

# Detecting Sandbox Artifacts
   Sandboxes typically have specific characteristics, such as low amounts of available memory, a small number of CPU cores, or unusual software configurations.

#### Checking System Resources
   Malware can query system resources like CPU cores, available memory, and hard disk space to check for sandbox-like environments that tend to have limited resources.

   Example: Checking CPU cores and memory
   ```cpp
   #include <windows.h>
   #include <iostream>

   bool IsSandbox() {
       SYSTEM_INFO sysInfo;
       GetSystemInfo(&sysInfo);

       // Check if the system has fewer than 2 CPUs
       if (sysInfo.dwNumberOfProcessors < 2) {
           std::cout << "Running in a sandbox (less than 2 CPUs)." << std::endl;
           return true;
       }

       MEMORYSTATUSEX memStatus;
       memStatus.dwLength = sizeof(MEMORYSTATUSEX);
       GlobalMemoryStatusEx(&memStatus);

       // Check if the system has less than 4GB of RAM
       if (memStatus.ullTotalPhys < (4ULL * 1024 * 1024 * 1024)) {
           std::cout << "Running in a sandbox (less than 4GB RAM)." << std::endl;
           return true;
       }

       return false;
   }

   int main() {
       if (IsSandbox()) {
           std::cout << "Sandbox environment detected!" << std::endl;
       } else {
           std::cout << "No sandbox detected." << std::endl;
       }
   }
   ```

   Explanation:
   This code checks the number of available CPU cores and the total physical memory. Sandboxes often run with minimal system resources (e.g., 1 CPU core, limited memory), and malware can use these resource checks to detect if it’s running in a restricted environment.

# Checking for Common Sandbox Artifacts
   Sandboxes typically have default configurations and often contain specific user names, hardware details, or file paths that can be detected by malware.

#### Checking for Default Usernames or File Paths
   Malware can check for common sandbox user names (e.g., `sandbox`, `analysis`, `malware`) or look for telltale file paths often used by sandboxes.

   Example: Checking the current username
   ```cpp
   #include <windows.h>
   #include <iostream>

   bool Is

SandboxUser() {
       char username[256];
       DWORD username_len = sizeof(username);

       if (GetUserNameA(username, &username_len)) {
           std::cout << "Current username: " << username << std::endl;

           // Check for known sandbox usernames
           if (strcmp(username, "sandbox") == 0 || strcmp(username, "malware") == 0 || strcmp(username, "analysis") == 0) {
               return true;
           }
       }
       return false;
   }

   int main() {
       if (IsSandboxUser()) {
           std::cout << "Sandbox user detected!" << std::endl;
       } else {
           std::cout << "No sandbox user detected." << std::endl;
       }
   }
   ```

   Explanation:
   This code checks the current username and compares it to common sandbox-related usernames. Many sandboxes use default names like `sandbox`, and malware can use this to detect if it’s being analyzed.

# Environment-Specific Techniques
   Malware can also check for other environmental artifacts like open network ports or connected devices. For example, it can check if it is running on a domain or if the network card has a MAC address typical of virtualization (e.g., MAC addresses associated with VMware or VirtualBox).

#### Checking MAC Addresses
   MAC addresses of network cards in virtual environments often have specific prefixes associated with VMware, VirtualBox, etc. Malware can query the MAC address and look for known virtual prefixes.