# Index 
- [[7. Advanced Techniques]]
	- [[7.1 Code Reuse (API Unhooking and Windows Code Reuse)]]
	- [[7.2 Syscall Usage (Direct System Calls)]]
	- [[7.3 In-memory Execution (Reflective DLL Injection)]]
	- [[7.4 In-memory Execution of Shellcode (Payload Execution)]]
	- [[7.5 Reflective DLL Injection]]
	- [[7.6 Evading Dynamic Analysis (Anti-VM and Anti-Sandbox Techniques)]]

# Understanding the Windows API vs. Syscalls

The Windows API (WinAPI) provides higher-level functions (e.g., `CreateProcess`, `VirtualAlloc`, `ReadFile`) that internally translate into syscalls when they interact with the kernel. For instance, `CreateProcess` eventually results in a syscall to the kernel through a function like `NtCreateProcess`.

The syscall interface is the lowest-level communication method between user-mode applications and the Windows kernel. A syscall involves placing parameters in specific registers and issuing the `syscall` instruction, which transfers control to the kernel.

#### Why Bypass the API?
- API Hooking: AV/EDR solutions commonly hook API calls at the user-mode level (e.g., they intercept `CreateProcess`).
- Syscalls are harder to monitor: Syscalls occur in kernel mode, which means user-mode hooks don't easily intercept them.

# How to Invoke Syscalls Directly in C++

In Windows, direct syscall invocation involves identifying the syscall number associated with the desired function and placing the required parameters in registers according to the calling convention.

Syscall numbers vary between Windows versions (e.g., Windows 10, Windows 11), so you need to determine the correct syscall number for the target version.

#### Steps to Call a Syscall in C++

1. Find the syscall number for the specific system call (e.g., `NtCreateFile`, `NtAllocateVirtualMemory`).
   
   You can use tools like:
   - SysInternals Process Monitor: To observe the syscalls invoked by API functions.
   - IDA Pro or Ghidra: To reverse engineer the Windows binaries and identify the syscall numbers.

2. Set up the registers with the parameters expected by the syscall.
3. Use inline assembly or machine code to issue the `syscall` instruction.

#### Example: Direct Syscall for `NtCreateFile`

The following example demonstrates how to invoke the `NtCreateFile` syscall directly. This syscall allows you to create or open a file in the kernel without using the `CreateFile` API (which AV solutions often monitor).

```cpp
#include <windows.h>
#include <iostream>

// NTSTATUS type definition
typedef LONG NTSTATUS;
#define STATUS_SUCCESS 0x00000000

// Define the NtCreateFile function prototype
extern "C" NTSTATUS NtCreateFile(
    PHANDLE FileHandle,
    ACCESS_MASK DesiredAccess,
    POBJECT_ATTRIBUTES ObjectAttributes,
    PIO_STATUS_BLOCK IoStatusBlock,
    PLARGE_INTEGER AllocationSize,
    ULONG FileAttributes,
    ULONG ShareAccess,
    ULONG CreateDisposition,
    ULONG CreateOptions,
    PVOID EaBuffer,
    ULONG EaLength
);

int main() {
    HANDLE fileHandle;
    OBJECT_ATTRIBUTES objAttr;
    IO_STATUS_BLOCK ioStatus;
    UNICODE_STRING fileName;
    RtlInitUnicodeString(&fileName, L"\\??\\C:\\TestFile.txt");

    // Initialize OBJECT_ATTRIBUTES structure
    InitializeObjectAttributes(&objAttr, &fileName, OBJ_CASE_INSENSITIVE, NULL, NULL);

    // Call NtCreateFile via direct syscall
    NTSTATUS status = NtCreateFile(&fileHandle, GENERIC_WRITE, &objAttr, &ioStatus, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_CREATE, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);

    if (status == STATUS_SUCCESS) {
        std::cout << "File created successfully!" << std::endl;
        CloseHandle(fileHandle);
    } else {
        std::cout << "Failed to create file. Status: " << std::hex << status << std::endl;
    }

    return 0;
}
```

#### Explanation of the Code
1. NtCreateFile is an undocumented function in `ntdll.dll` that eventually translates to a syscall. This bypasses API hooking layers like `CreateFile`.
2. OBJECT_ATTRIBUTES and UNICODE_STRING are initialized to specify the target file's path and properties.
3. NtCreateFile is called directly, issuing the syscall to open or create the file.
   
   > Note: To ensure this code works across different Windows versions, you need to dynamically retrieve the syscall number from `ntdll.dll`.

# Challenges with Syscall Usage Across Windows Versions

Syscall numbers are not consistent across different versions of Windows. The syscall number for `NtCreateFile` in Windows 10 might be different from that in Windows 11. Therefore, if you hard-code the syscall number, your code may break on other versions of Windows.

#### Solutions
- Dynamically Retrieve Syscall Numbers: One method is to retrieve the syscall number dynamically at runtime by parsing the `ntdll.dll` binary, as the syscall number for a function like `NtCreateFile` can be found in its first few instructions.

You can use manual syscall resolution with code like this:

```cpp
#include <windows.h>
#include <iostream>

DWORD GetSyscallNumber(const char* functionName) {
    HMODULE hNtdll = LoadLibraryA("ntdll.dll");
    if (!hNtdll) return -1;

    FARPROC procAddress = GetProcAddress(hNtdll, functionName);
    if (!procAddress) return -1;

    unsigned char* func = (unsigned char*)procAddress;

    // Syscall number is usually at instruction offset 4 or 5
    // 0x0F 0x05 = syscall instruction
    return *(DWORD*)(func + 4);
}

int main() {
    DWORD syscallNumber = GetSyscallNumber("NtCreateFile");
    std::cout << "NtCreateFile syscall number: " << std::hex << syscallNumber << std::endl;

    return 0;
}
```

In this code:
- We dynamically retrieve the syscall number of a function (e.g., `NtCreateFile`) by examining the first few instructions of its implementation in `ntdll.dll`.

# Practical Example: Using Syscalls for Process Creation

Another common use of syscalls is for process creation. Let’s invoke `NtCreateProcess` directly to bypass the standard API.

Here’s a simplified example:

```cpp
#include <windows.h>
#include <iostream>

typedef LONG NTSTATUS;
#define STATUS_SUCCESS 0x00000000

typedef NTSTATUS (NTAPI *pNtCreateProcess)(
    PHANDLE ProcessHandle,
    ACCESS_MASK DesiredAccess,
    POBJECT_ATTRIBUTES ObjectAttributes,
    HANDLE ParentProcess,
    BOOLEAN InheritObjectTable,
    HANDLE SectionHandle,
    HANDLE DebugPort,
    HANDLE ExceptionPort
);

int main() {
    HMODULE ntdll = LoadLibraryA("ntdll.dll");
    pNtCreateProcess NtCreateProcess = (pNtCreateProcess)GetProcAddress(ntdll, "NtCreateProcess");

    HANDLE processHandle;
    OBJECT_ATTRIBUTES objAttr;

    InitializeObjectAttributes(&objAttr, NULL, 0, NULL, NULL);

    NTSTATUS status = NtCreateProcess(
        &processHandle,
        PROCESS_ALL_ACCESS,
        &objAttr,
        GetCurrentProcess(),
        TRUE,
        NULL,
        NULL,
        NULL
    );

    if (status == STATUS_SUCCESS) {
        std::cout << "Process created successfully!" << std::endl;
    } else {
        std::cout << "Failed to create process. Status: " << std::hex << status << std::endl;
    }

    return 0;
}
```

#### Explanation
- We dynamically load the `NtCreateProcess` function from `ntdll.dll`.
- We manually invoke the syscall for process creation, bypassing the normal Windows API functions like `CreateProcess`.

# Advanced Considerations for Evasion

1. Anti-heuristic Measures: Syscall-based methods may still trigger AV/EDR solutions if the behavior of the code is suspicious (e.g., creating remote threads, modifying protected memory).
   
   Suggestions:
   - Obfuscate Syscalls: Use obfuscation to avoid static detection of known syscall patterns.
   - Stealthy Execution: Mimic legitimate processes' behavior to blend in and avoid drawing attention.

2. AV/EDR Monitoring of Syscalls: Although syscalls are harder to monitor, some advanced EDR systems hook the kernel and can detect syscall patterns. In these cases, you need to combine syscall usage with other evasion techniques, such as timing delays, user-interaction triggers, or code-staging techniques.