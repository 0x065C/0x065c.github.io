# Index 
- [[Malware Development]]
	- [[4. Bypassing Antivirus (AV)]]
		- [[4.1 Static Analysis Evasion]]
		- [[4.2 Behavioral and Heuristic Evasion]]
		- [[4.3 Anti-Analysis Techniques]]

# Static Analysis Evasion

Static analysis focuses on analyzing the binary without executing it. Many AV solutions rely on signature-based detection or pattern matching to catch known malware samples. To evade static analysis, you'll need to avoid known patterns or signatures in the malware binary.

#### Techniques for Static Analysis Evasion

1.1. Code Obfuscation:
   - String Obfuscation: AV solutions often scan for specific strings (e.g., IP addresses, URLs, registry keys) within an executable. To evade this, you can:
     - Encrypt or encode strings (e.g., XOR, Base64) and decrypt them at runtime.
     - Store sensitive information in memory and avoid writing it directly to disk.
     - Example in C++:
       ```cpp
       std::string decryptString(std::string encrypted) {
           for (char &c : encrypted) {
               c ^= 0xAA;  // XOR encryption key
           }
           return encrypted;
       }
       ```
   - Code Obfuscation Tools: Use tools like Obfuscator-LLVM or write your own obfuscation routines to modify loops, function names, and flow controls to make the code harder to reverse-engineer.
   
1.2. Binary Packing/Compression:
   - Compress or "pack" your malware binary using tools like UPX, but be aware that most AVs can detect common packers.
   - A more effective approach is to create your custom packer:
     - Your packer should encrypt the malicious payload and decrypt it during runtime.
     - Unpack the payload in memory to avoid writing it to disk, making it more difficult for AVs to analyze.
     - Example of a simple custom packer concept:
       ```cpp
       void unpack_and_execute(char *packed_data, int data_length) {
           // Decrypt the packed binary
           for (int i = 0; i < data_length; ++i) {
               packed_data[i] ^= 0xAA;  // XOR decryption
           }
           // Inject or execute the unpacked payload
           execute_in_memory(packed_data);
       }
       ```

1.3. Modify PE File Structure:
   - AVs often check certain parts of the Portable Executable (PE) header, like section names (`.text`, `.rdata`). Changing these section names or adding non-standard sections can make your binary less recognizable.
   - Fuzzing the PE header by modifying checksum values or padding data can confuse AV systems during the scanning process.

1.4. Polymorphic and Metamorphic Code:
   - Polymorphic Malware: Every time the malware is compiled, it changes its code structure (e.g., by renaming functions, adding junk code) without changing its functionality. This makes it difficult for signature-based AVs to detect consistent patterns.
   - Metamorphic Malware: Takes polymorphism further by rewriting its own code during execution, so even the in-memory image of the malware looks different each time it runs.

1.5. Anti-Signature Techniques:
   - Control Flow Obfuscation: Modify the control flow of your code by adding redundant jumps, loops, and other instructions that AV systems will have trouble analyzing statically.
   - Inline Assembly: For certain sensitive parts of the code, especially those interacting with the system, consider using inline assembly code instead of higher-level C++ functions. Inline assembly can avoid certain AV detections.
   - Self-Modifying Code: Use self-modifying code techniques where the malware modifies its own instructions during execution to avoid static analysis.

# Behavioral and Heuristic Evasion

Many modern AVs use dynamic analysis and heuristics to identify malware by observing how it behaves during execution. If your malware behaves suspiciously (e.g., opening connections to remote servers, injecting into other processes), it will likely trigger alerts.

#### Techniques for Behavioral and Heuristic Evasion

2.1. Delayed Execution:
   - Timing-based delays: Many AV systems execute malware in a sandbox environment and monitor its behavior. You can add a delay using `Sleep()` functions or other timing mechanisms to outlast the AV’s observation period.
     ```cpp
     Sleep(30000);  // Delay execution by 30 seconds to bypass short sandbox run times
     ```
   - User Interaction Triggers: Instead of executing malicious code immediately, wait for specific user actions (e.g., mouse movement, file opening). Sandboxes typically do not simulate real user behavior.

2.2. Avoid Suspicious API Calls:
   - Some Windows API functions are flagged as suspicious by AV systems. For example:
     - `CreateRemoteThread`: Used for process injection.
     - `WriteProcessMemory`: Used for modifying other processes’ memory.
     - `VirtualAllocEx`: Allocates memory in a remote process.
   - Alternative Approach:
     - Direct Syscalls: Instead of using standard Windows API calls, you can invoke system calls directly by bypassing the WinAPI, making it harder for AVs to detect malicious activity.
     - Example: Instead of calling `CreateRemoteThread()`, use the NtCreateThreadEx syscall.
   
2.3. Use Trusted Processes for Execution:
   - Inject into trusted, signed processes (e.g., `explorer.exe`, `svchost.exe`). AVs tend to whitelist or trust these processes, so executing your payload within them can make detection harder.
   - Process Hollowing: Replace the contents of a legitimate process (e.g., `notepad.exe`) with your malware’s payload while retaining the legitimate process's name and metadata.
   
2.4. Legitimate API Misuse:
   - Use benign-looking API calls for malicious purposes. For example:
     - SetWindowsHookEx: Typically used for system-wide hooks, but can be leveraged for keylogging.
     - NtQuerySystemInformation: Use this function to gather system details that are normally benign but can aid in reconnaissance.

# Anti-Analysis Techniques

These techniques are aimed at avoiding detection during reverse engineering or dynamic analysis in a sandbox or VM.

#### Techniques for Anti-Analysis

3.1. Anti-Debugging Techniques:
   - Detect the presence of a debugger using functions like `IsDebuggerPresent()` or check the Process Environment Block (PEB) to see if debugging flags are set:
     ```cpp
     if (IsDebuggerPresent()) {
         ExitProcess(0);  // Exit if a debugger is detected
     }
     ```
   - Modify the SEH (Structured Exception Handling) table to create fake exceptions that throw off reverse engineering tools.

3.2. Anti-VM and Sandbox Detection:
   - Malware sandboxes or analysis environments often run on virtual machines. You can detect VMs by:
     - Checking hardware properties (e.g., look for VM-related hardware like `VMware`, `VirtualBox`).
     - Checking the BIOS and registry keys for indicators of virtual environments.
     - Example VM detection:
       ```cpp
       char* vmware_str = "VMware";
       if (strstr(GetSystemFirmwareTable('RSMB', 0, NULL, 0), vmware_str)) {
           ExitProcess(0);  // Exit if running in a VM
       }
       ```
   - Detect sandbox artifacts (e.g., short run-time, lack of typical user activity, certain CPU features missing) to differentiate between real and sandboxed environments.

3.3. Code Packing and Unpacking In-Memory:
   - Execute your payload entirely from memory without writing anything to disk. This is known as reflective DLL injection. Since nothing is written to disk, AV systems that scan files for malicious content are bypassed.
   - Reflective DLL injection involves loading a DLL from memory and manually resolving its dependencies without using the Windows loader.

3.4. Environment Checks:
   - Check the presence of certain files, processes, or network connections that would normally be present on a real system but may not exist in a sandbox or VM.
   - Ensure that the environment is legitimate by checking for installed software or connected devices that a typical user would have.

# Putting It All Together
To effectively bypass antivirus, you will typically combine multiple evasion techniques, such as:
- Packing the malware with a custom packer.
- Obfuscating the code and strings.
- Avoiding suspicious API calls by using direct syscalls.
- Injecting into trusted processes (like `explorer.exe`).
- Detecting sandboxes and VMs before executing the main payload.

These techniques combined can significantly reduce the chances of detection. However, it’s essential to test these techniques in various environments to understand their effectiveness.

Would you like to explore code examples or work on a sample project to put these concepts into practice?