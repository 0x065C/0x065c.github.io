# Index 
- [[4. Bypassing Antivirus (AV)]]
	- [[4.1 Static Analysis Evasion]]
	- [[4.2 Behavioral and Heuristic Evasion]]
	- [[4.3 Anti-Analysis Techniques]]

# Code Obfuscation

Code obfuscation is the process of modifying code to make it harder to understand or analyze without changing its functionality. This is a crucial technique for evading signature-based AVs, as the AV looks for known patterns in the binary (e.g., specific function names, strings, or code sequences).

#### Techniques

1. String Encryption and Obfuscation:
   Strings are often used as signatures in AV detection. For example, the presence of known URLs, IP addresses, file paths, or API function names may trigger an AV alert.

   - Encrypting strings using simple ciphers like XOR or Base64, or more complex algorithms like AES, makes it harder for AV systems to recognize them.
   - Decryption at runtime: The strings should be decrypted only at runtime, just before they are used. This ensures that during static analysis, the strings remain obfuscated.
   
   Example:
   ```cpp
   std::string encryptString(std::string input) {
       for (char &c : input) {
           c ^= 0xAA;  // Simple XOR encryption
       }
       return input;
   }

   std::string decryptString(std::string input) {
       for (char &c : input) {
           c ^= 0xAA;  // XOR decryption
       }
       return input;
   }
   
   // Usage
   std::string encryptedUrl = encryptString("http://malicious-url.com");
   std::string decryptedUrl = decryptString(encryptedUrl);  // Use it only at runtime
   ```

2. Control Flow Obfuscation:
   Modifying the control flow of your code to confuse the AV engine is another effective technique. Adding unnecessary jumps, loops, or redundant conditions makes the program logic harder to analyze statically.

   - Opaque predicates: These are conditions that are always true or false, but they confuse static analysis engines because the AV cannot easily deduce their behavior.
   - Inserting junk code: Add no-op operations or redundant calculations to alter the binary’s appearance.

   Example:
   ```cpp
   int dummyFunc() {
       // Opaque predicate: This will always return true
       if ((2 * 2) == 4) {
           return 1; // AV may have difficulty understanding this
       }
       return 0;
   }
   
   void executePayload() {
       if (dummyFunc()) {
           // Original malicious code
       }
   }
   ```

3. Inlined Functions and Flattened Code:
   Instead of calling standard library functions, inline critical functions directly within your code. This reduces the reliance on recognizable library calls that AVs may flag. You can also "flatten" your code by reducing the use of functions and placing more operations in a linear execution path.

4. Compiler-level Obfuscation:
   Use custom or modified compilers that introduce additional layers of obfuscation, such as LLVM obfuscator. These tools automatically obfuscate control flow, encrypt strings, and scramble code structures without changing the high-level source code.

# Binary Packing and Compression

Packing refers to compressing or encrypting the entire binary to hide the malicious payload from AVs. It’s a common static analysis evasion technique because the packed executable does not reveal its true contents until it’s unpacked during runtime.

#### Techniques

1. Custom Packers:
   Writing your own custom packer helps avoid detection by AV engines that can recognize common packers (like UPX). A custom packer works by:
   
   - Encrypting the payload and storing it in a compressed form.
   - During execution, the packer decrypts the payload in memory, then either directly executes it or injects it into another process.

   Basic Concept:
   ```cpp
   // Simple XOR-encrypted payload
   const char encryptedPayload[] = { /* Encrypted binary data */ };

   void decryptAndExecute() {
       // Decrypt payload in memory
       char decryptedPayload[sizeof(encryptedPayload)];
       for (int i = 0; i < sizeof(encryptedPayload); ++i) {
           decryptedPayload[i] = encryptedPayload[i] ^ 0xAA;
       }
       
       // Execute decrypted payload
       execute_in_memory(decryptedPayload);
   }
   ```

2. Packing Only Certain Sections:
   You can choose to pack only certain sections of the binary (like the `.text` or `.data` sections) to keep critical code obfuscated while leaving other parts (e.g., resources) unpacked. This selective packing can throw off AVs during static analysis, as they might not detect the packed sections.

3. Runtime Decryption and Execution:
   In memory-based execution (e.g., reflective DLL injection) is one of the best ways to evade static detection. The payload is decrypted or unpacked in memory, and nothing is written to disk.

   - Reflective DLL Injection: This technique allows a DLL to load itself into memory without being written to disk or using the standard Windows loader. AVs focused on static file scanning will not detect the malicious payload.
   
   Example Concept:
   - Write a simple reflective loader that decrypts a DLL from memory and uses `LoadLibrary` or `NtCreateThreadEx` to execute it.

# PE File Manipulation

The Portable Executable (PE) format is the standard format for executables, DLLs, and other binary files in Windows. AVs heavily rely on analyzing the structure of the PE file to identify malware. Manipulating the PE structure can confuse AV engines and evade detection.

#### Techniques

1. Section Name Modification:
   PE files have different sections such as `.text`, `.rdata`, `.data`, and `.rsrc`. AVs look for specific patterns in these sections, especially `.text` (where code is stored) and `.rdata` (where read-only data is stored).

   - Change section names to non-standard names or random strings. For example, rename `.text` to `.xyz123`, which might evade signature-based AV detection.

   Example:
   You can manually modify the PE header to change section names, or use tools like LordPE or PE Tools for this purpose.

2. Section Padding:
   AVs often scan the PE file's header and sections for specific offsets and known patterns. By adding padding (extra, meaningless data) to certain sections, you can shift the code and data offsets to confuse the AV.

   - Add junk sections: Add sections that don’t perform any useful function but alter the layout of the PE file.
   
   Example:
   - Append a random `.junk` section with meaningless data to the PE file.

3. PE Header Fuzzing:
   The PE header contains metadata about the executable, including entry points, section sizes, and imports. Modifying these headers (e.g., changing the entry point) can break the pattern recognition algorithms used by AV engines.

   - Checksum tampering: The checksum in the PE header can be modified or removed entirely to confuse static analysis.
   - Entry Point Redirection: Alter the PE file's entry point to point to a new code section that unpacks the actual malicious code before jumping to the original entry point.

   Example Concept:
   - Redirect the entry point to a decryption routine that decrypts the main payload and then jumps to the original entry point.

# Polymorphic and Metamorphic Malware

Polymorphic and metamorphic techniques are among the most advanced static analysis evasion techniques because they dynamically alter the binary or code to appear different on every execution.

#### Techniques

1. Polymorphic Malware:
   - Polymorphic code changes the structure of the malware with each new instance (e.g., encryption keys, function names) while maintaining the same functionality.
   - Stub Encryption: The malware uses an encryption engine (a "stub") that decrypts the payload, but the decryption stub itself changes each time, making it difficult for AVs to create a consistent signature.
   
   Example Concept:
   - Each new instance of the malware changes the encryption key and stub used to decrypt the malicious payload.

2. Metamorphic Malware:
   - Metamorphic code rewrites its own code during runtime or recompiles itself to look entirely different each time it runs.
   - This can be achieved by dynamically changing function names, reordering instructions, replacing certain operations with equivalent ones, or using different encryption algorithms.

   Example Concept:
   - On each execution, the malware uses a different function for its core operations (e.g., if one version uses `add` for a particular task, another version may use `sub` with inverted operands).

3. Code Rewriting Techniques:
   - Code Mutation: Use mutation engines to rewrite the binary with functionally equivalent, but structurally different, instructions. For example, swapping registers, modifying jump targets, and changing loop structures without altering the core functionality.

 Example:
   ```cpp
   // Original code
   int addNumbers(int a, int b) {
       return a + b;
   }

   // Mutated code
   int addNumbers(int a, int b) {
       int result;
       __asm {
           mov eax, a
           add eax, b
           mov result, eax
       }
       return result;
   }
   ```

   This level of code mutation makes it difficult for AVs to detect consistent patterns.