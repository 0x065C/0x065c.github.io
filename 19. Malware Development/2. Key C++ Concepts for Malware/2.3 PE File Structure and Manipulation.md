# Index 
- [[2. Key C++ Concepts for Malware]]
	- [[2.1 Windows API (WinAPI) for Malware Development]]
	- [[2.2 Code Obfuscation Techniques]]
	- [[2.3 PE File Structure and Manipulation]]
	- [[2.4 DLL Injection Techniques]]

# Overview of the PE File Structure

At a high level, the PE file structure consists of a DOS Header, PE Header, and a series of sections, each serving a specific purpose. The most important parts include:
- DOS Header (MZ Header)
- PE Header (NT Header)
- Optional Header
- Section Table
- Sections (.text, .data, etc.)

A simplified diagram of the PE file structure looks like this:

```
++   <- DOS Header (MZ)
|   DOS Header     |
++   <- DOS Stub
|    DOS Stub      |
++   <- PE Signature (PE\0\0)
|  PE Signature    |
++   <- COFF File Header
|   PE Header      |
++   <- Optional Header
| Optional Header  |
++   <- Section Table
|  Section Table   |
++   <- Section 1 (.text)
|     .text        |
++   <- Section 2 (.data)
|     .data        |
++
|      ...         |
++
```

Letâ€™s dive into each part and understand how to manipulate the structure for malware development and antivirus evasion.

# Key Components of the PE File Structure

#### DOS Header (MZ Header)
The DOS Header is the first part of the file, starting with the magic number `MZ` (0x5A4D). This header allows legacy DOS systems to execute a basic message like "This program cannot be run in DOS mode." The e_lfanew field in this header is important because it contains the offset to the PE Header (NT Header).

- e_lfanew: This is a pointer to the start of the PE Header. By modifying this value, you can attempt to confuse parsers, though this is often detected.

Example:
```cpp
struct IMAGE_DOS_HEADER dosHeader;
fread(&dosHeader, sizeof(IMAGE_DOS_HEADER), 1, file);
printf("Offset to PE Header: 0x%lx\n", dosHeader.e_lfanew);
```

#### PE Header (NT Headers)
The PE Header begins with the signature `PE\0\0` (50 45 00 00). It contains important metadata about the file such as the number of sections, time stamp, and characteristics.

- FileHeader: The COFF (Common Object File Format) Header defines basic information such as machine type, number of sections, and the entry point for the executable.

- Optional Header: Despite its name, the Optional Header is mandatory for executables. It contains fields such as the entry point (`AddressOfEntryPoint`), image base, section alignment, and size of the code.

Key Fields:
- AddressOfEntryPoint: The starting address for the execution of the binary.
- ImageBase: The preferred load address in memory.
- SizeOfImage: Total size of the loaded image, including all sections.
- SizeOfHeaders: Size of all headers combined.

#### Section Table
The Section Table follows the Optional Header. Each entry in this table describes a section of the PE file. The most important fields in the Section Table include:
- Name: The name of the section (e.g., `.text`, `.data`).
- VirtualSize: The size of the section when loaded into memory.
- VirtualAddress: The address where the section is loaded into memory (relative to the image base).
- SizeOfRawData: The size of the section data in the file.
- PointerToRawData: Offset of the section data from the start of the file.

Sections of interest include:
- .text: Contains executable code.
- .data: Stores global/static variables.
- .rdata: Holds read-only data, such as constants or import tables.
- .rsrc: Stores resources like icons, dialogs, and strings.
- .reloc: Contains relocation information for the loader.

Example:
```cpp
struct IMAGE_SECTION_HEADER section;
fseek(file, dosHeader.e_lfanew + sizeof(IMAGE_NT_HEADERS), SEEK_SET);
fread(&section, sizeof(IMAGE_SECTION_HEADER), 1, file);
printf("Section Name: %s\n", section.Name);
printf("Virtual Address: 0x%lx\n", section.VirtualAddress);
```

# PE File Manipulation Techniques

Understanding how to manipulate the PE file structure is critical for antivirus evasion and custom malware development. Let's explore common manipulation techniques.

#### Modifying the Entry Point
The AddressOfEntryPoint field in the Optional Header specifies where execution starts. By modifying this value, you can change the behavior of the malware and confuse static analysis tools.

Example of modifying the entry point:
1. Change the AddressOfEntryPoint to point to a custom section (or shellcode).
2. After execution, return to the original entry point to preserve normal program behavior.

```cpp
IMAGE_NT_HEADERS ntHeaders;
fseek(file, dosHeader.e_lfanew, SEEK_SET);
fread(&ntHeaders, sizeof(IMAGE_NT_HEADERS), 1, file);

// Change entry point to your code
ntHeaders.OptionalHeader.AddressOfEntryPoint = 0x123456;

// Write back the modified header
fseek(file, dosHeader.e_lfanew, SEEK_SET);
fwrite(&ntHeaders, sizeof(IMAGE_NT_HEADERS), 1, file);
```

#### Adding a New Section
Adding a new section is useful when you want to store malicious code or data in a PE file. By modifying the Section Table, you can introduce new sections like `.mycode` or `.shellcode`.

Steps to add a section:
1. Modify the Section Table to include a new section entry.
2. Adjust the NumberOfSections in the PE Header.
3. Update the SizeOfImage field to accommodate the new section.

Example:
```cpp
// Assume sectionTable is a pointer to the section table
strncpy(sectionTable[oldNumberOfSections].Name, ".mysec", 8);
sectionTable[oldNumberOfSections].VirtualAddress = nextAvailableAddress;
sectionTable[oldNumberOfSections].SizeOfRawData = 0x200;  // Size of new section
sectionTable[oldNumberOfSections].PointerToRawData = offsetInFile;
```

After adding a new section, you can inject malicious code into this section and then modify the AddressOfEntryPoint to point to this section.

#### Packing and Compression (Custom Packers)
Packing refers to compressing or encrypting sections of the PE file and then decompressing them in memory at runtime. The idea is to make the binary harder to analyze and detect.

- UPX is a well-known packer, but most AV engines can detect it. To evade detection, you can modify or write your own custom packer.

Steps for custom packing:
1. Compress the `.text` section (or the entire binary).
2. Modify the entry point to point to a small stub (unpacker).
3. The unpacker decompresses the original code in memory and jumps to the original entry point.

Example (pseudo-code for custom unpacker):
```cpp
void unpack_and_execute() {
    // Decrypt or decompress the packed section
    decompress_section(packed_section, original_code);
    
    // Jump to the original entry point
    jump_to(original_entry_point);
}
```

#### Modifying Import Table
PE files use an Import Address Table (IAT) to resolve external function addresses at runtime. Malware can manipulate the IAT to hook or redirect API calls.

For example, instead of calling the genuine `WriteFile` function from `kernel32.dll`, the malware could hook this function to execute malicious code before or after the legitimate function is called.

Steps to hook API calls via IAT:
1. Locate the IAT in the PE file.
2. Replace the address of a function (e.g., `WriteFile`) with your malicious function.

Example (IAT Hooking):
```cpp
// Locate IAT entry for WriteFile
PVOID* pIAT_WriteFile = (PVOID*)Find_IAT_Entry("WriteFile");

// Replace it with the address of your custom function
*pIAT_WriteFile = (PVOID)&MyMaliciousWriteFile;
```

#### Modifying the PE Header to Confuse Analysis Tools
You can introduce subtle modifications to the PE header that confuse analysis tools without breaking the functionality of the PE file. Some examples include:
- Mismatching sizes: Report incorrect SizeOfImage or SizeOfHeaders to mislead static analyzers.
- Checksum modification: Modify or zero out the checksum to bypass certain checks.

Example:
```cpp
ntHeaders.OptionalHeader.CheckSum = 0;  // Disable checksum validation
```

# In-Memory Execution

To evade file-based detection, malware can run its payload directly from memory without ever writing it to disk. This is

 referred to as reflective loading. In this case, the PE loader is implemented in the malware itself, loading a PE from memory instead of disk.

Reflective PE loading steps:
1. Load the PE file into memory.
2. Parse the headers and sections.
3. Resolve imports and relocations.
4. Set up the entry point and execute.

You can use libraries like libpeconv (C++) for implementing in-memory PE loading.