# Index 
- [[2. Key C++ Concepts for Malware]]
	- [[2.1 Windows API (WinAPI) for Malware Development]]
	- [[2.2 Code Obfuscation Techniques]]
	- [[2.3 PE File Structure and Manipulation]]
	- [[2.4 DLL Injection Techniques]]

# String Obfuscation

String literals are often a giveaway in malware binaries. Static AV engines look for known malicious strings, such as file paths, URLs, or command-and-control (C2) domains, to identify malware. String obfuscation makes it harder for AV software to recognize and flag such strings.

#### Basic XOR String Encryption
XOR encryption is a simple, fast, and effective method for obfuscating strings. The idea is to XOR each character of the string with a predefined key, and then XOR it again during execution to reveal the original string. This makes the string unreadable in a static scan.

Example:

```cpp
std::string xorEncryptDecrypt(std::string input, char key) {
    std::string output = input;
    for (int i = 0; i < input.size(); i++) {
        output[i] = input[i] ^ key;  // XOR encryption/decryption
    }
    return output;
}

int main() {
    std::string secret = "MaliciousCode!";
    char key = 0x5F;  // Secret key
    std::string encrypted = xorEncryptDecrypt(secret, key);
    
    // Print encrypted string (appears as gibberish)
    std::cout << "Encrypted: " << encrypted << std::endl;
    
    // Decrypt at runtime
    std::string decrypted = xorEncryptDecrypt(encrypted, key);
    std::cout << "Decrypted: " << decrypted << std::endl;
    
    return 0;
}
```

When AV software scans the binary, it will only see the XOR-obfuscated string. The real string is only revealed during runtime.

#### Advanced String Obfuscation with Base64

Base64 encoding is another popular technique to hide strings. While it's not true encryption, Base64 can help avoid AV detection by converting binary data into ASCII strings. Here's an example where a string is Base64-encoded and then decoded at runtime.

Example:

```cpp
#include <iostream>
#include <string>
#include <openssl/bio.h>
#include <openssl/evp.h>
#include <openssl/buffer.h>

std::string base64Encode(const std::string& input) {
    BIO *bio, *b64;
    BUF_MEM *bufferPtr;
    
    b64 = BIO_new(BIO_f_base64());
    bio = BIO_new(BIO_s_mem());
    bio = BIO_push(b64, bio);
    
    BIO_write(bio, input.c_str(), input.length());
    BIO_flush(bio);
    BIO_get_mem_ptr(bio, &bufferPtr);
    
    std::string encodedData(bufferPtr->data, bufferPtr->length);
    BIO_free_all(bio);
    
    return encodedData;
}

std::string base64Decode(const std::string& encoded) {
    BIO *bio, *b64;
    char buffer[512];
    memset(buffer, 0, 512);

    b64 = BIO_new(BIO_f_base64());
    bio = BIO_new_mem_buf(encoded.c_str(), -1);
    bio = BIO_push(b64, bio);
    
    int decodedLength = BIO_read(bio, buffer, encoded.size());
    BIO_free_all(bio);
    
    return std::string(buffer, decodedLength);
}

int main() {
    std::string secret = "https://malicious-site.com";
    
    // Base64 Encode
    std::string encoded = base64Encode(secret);
    std::cout << "Encoded: " << encoded << std::endl;

    // Decode at runtime
    std::string decoded = base64Decode(encoded);
    std::cout << "Decoded: " << decoded << std::endl;

    return 0;
}
```

In this case, the Base64-encoded string can bypass basic static scanning, as it doesn’t match any known patterns for malicious URLs. Only at runtime is the original string restored.

#### Custom String Obfuscation Techniques

More advanced malware developers often design their own custom encryption or encoding schemes. The idea is to use a unique method that isn't widely recognized by AV engines. For instance, you could mix multiple encryption techniques or add noise to your strings to further complicate decryption during analysis.

# Control Flow Obfuscation

Control flow obfuscation makes the logic of the program harder to follow by introducing unnecessary conditional branches, jumps, and loops. It confuses static analysis tools and makes reverse-engineering more difficult.

#### Opaque Predicates

An opaque predicate is a condition that always evaluates to a specific value (true or false), but appears complex to analysis tools. Malware authors use these to insert dummy code branches or jumps that mislead analysts or reverse engineers.

Example:

```cpp
void executeMalware() {
    if ((12345 * 6789) % 2 == 0) {  // Always true
        std::cout << "Malware executed!" << std::endl;
        // Real malicious code here
    } else {
        std::cout << "This should never happen!" << std::endl;
        // Fake code to confuse analysts
    }
}
```

This example introduces a branching condition that always leads to the execution of the malware, but the complexity of the condition may confuse AV systems or reverse engineers.

#### Control Flow Flattening

Control flow flattening is a more advanced technique that rearranges the program’s flow in a way that makes it harder to follow. It involves removing the direct flow of instructions (such as loops and conditionals) and replacing them with a dispatcher loop that manages which code block to execute next.

Example:

```cpp
void obfuscatedControlFlow() {
    int state = 0;

    while (state != -1) {
        switch (state) {
            case 0:
                // Initial code block
                std::cout << "Block 1" << std::endl;
                state = 1;  // Move to next block
                break;

            case 1:
                // Second code block
                std::cout << "Block 2" << std::endl;
                state = -1;  // Exit loop
                break;

            default:
                state = -1;
                break;
        }
    }
}
```

In this case, the program's flow is flattened into a switch statement that changes state values to move between different code blocks. This flattening makes the program harder to understand at a glance since the natural flow of the code is obfuscated.

# Function Pointers and Dynamic Function Resolution

Instead of calling functions directly (which can be flagged by AV if known malicious functions like `CreateRemoteThread` are used), you can use function pointers or dynamically resolve functions at runtime.

#### Using Function Pointers

Function pointers allow for indirect function calls. Instead of making a direct call to a function, you store its address in a pointer and invoke it from there.

Example:

```cpp
#include <iostream>

void myFunction() {
    std::cout << "Executing malicious function..." << std::endl;
}

int main() {
    // Function pointer
    void (*funcPtr)() = myFunction;
    
    // Call via function pointer
    funcPtr();
    
    return 0;
}
```

Here, `myFunction` is called indirectly through `funcPtr`, which adds a layer of obfuscation to the execution flow.

#### Dynamic Function Resolution

You can dynamically resolve function addresses at runtime using `LoadLibrary` and `GetProcAddress`. This avoids direct calls to API functions and makes the binary harder to analyze statically.

Example:

```cpp
#include <windows.h>
#include <iostream>

typedef BOOL(WINAPI *pIsDebuggerPresent)();

int main() {
    HMODULE hKernel32 = LoadLibrary("kernel32.dll");
    if (hKernel32) {
        // Dynamically resolve IsDebuggerPresent
        pIsDebuggerPresent IsDebuggerPresent = (pIsDebuggerPresent)GetProcAddress(hKernel32, "IsDebuggerPresent");
        
        if (IsDebuggerPresent && IsDebuggerPresent()) {
            std::cout << "Debugger detected!" << std::endl;
        } else {
            std::cout << "No debugger." << std::endl;
        }

        FreeLibrary(hKernel32);
    }

    return 0;
}
```

Instead of statically linking `IsDebuggerPresent`, this code dynamically resolves it at runtime. Since AV systems often scan for known function calls like `IsDebuggerPresent`, dynamic resolution can make the malware more evasive.

# Inserting NOPs (No Operation Instructions)

Inserting `NOP` instructions (or their equivalent) is a low-level obfuscation technique to pad the code with meaningless instructions that do not change the program's behavior. It confuses analysts and makes the malware harder to reverse-engineer.

Example:

```cpp
__asm {
    NOP;  // No operation instruction
    NOP;
    mov eax, 5
    NOP;
    mov ebx, eax
}
```

Here, the `NOP` instructions do nothing but make the malware harder to analyze by introducing extra steps.

# Garbage Code Injection

Garbage code injection involves inserting non-functional or irrelevant code into the program. This increases the complexity of the malware and makes reverse-engineering more time-consuming.

Example:

```cpp
void garbage

Code() {
    int x = 100;
    for (int i = 0; i < 1000; ++i) {
        x += (i % 2 == 0) ? i : -i;  // Useless calculations
    }
    std::cout << "Useless value: " << x << std::endl;
}
```

The above example performs meaningless calculations that do not affect the program's logic but add complexity for anyone trying to reverse-engineer the malware.

# Instruction Substitution

Instead of using common instructions, malware developers can replace them with less frequently used alternatives or equivalent operations, which could help evade detection. For instance, instead of using a simple `mov` instruction, you could use `xor` to achieve the same result in an unexpected way.

Example:

```cpp
__asm {
    xor eax, eax  // Same as mov eax, 0
    sub ebx, ebx  // Same as mov ebx, 0
}
```

Here, instead of directly assigning zero to registers, the `xor` and `sub` instructions are used to achieve the same result but in an unexpected manner.